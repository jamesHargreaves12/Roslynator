<?xml version="1.0" encoding="utf-8"?>
<Analyzers>
  <Analyzer Identifier="AddBlankLineAfterEmbeddedStatement">
    <Id>RCS0001</Id>
    <Title>Add blank line after embedded statement.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
    Foo();
Bar();]]></Before>
        <After><![CDATA[if (x)
    Foo();

Bar();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddBlankLineAfterRegionDirective">
    <Id>RCS0002</Id>
    <Title>Add blank line after #region.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[class C
{
    #region Methods
    void M()
    {
    }
    
    #endregion
}]]></Before>
        <After><![CDATA[class C
{
    #region Methods

    void M()
    {
    }
    
    #endregion
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddBlankLineAfterUsingDirectiveList">
    <Id>RCS0003</Id>
    <Title>Add blank line after using directive list.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[// Copyright ...

using System;
using System.Linq;
namespace N
{
}]]></Before>
        <After><![CDATA[// Copyright ...

using System;
using System.Linq;

namespace N
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddEmptyLineBeforeClosingBraceOfDoStatement" IsObsolete="true">
    <Id>RCS0004</Id>
    <Title>Add empty line before closing brace of 'do' statement.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[do
{
    Foo();
} while (x);]]></Before>
        <After><![CDATA[do
{
    Foo();

} while (x);]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddBlankLineBeforeEndRegionDirective">
    <Id>RCS0005</Id>
    <Title>Add blank line before #endregion.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[class C
{
    #region Methods
    
    void M()
    {
    }
    #endregion
}]]></Before>
        <After><![CDATA[class C
{
    #region Methods

    void M()
    {
    }
    
    #endregion
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddBlankLineBeforeUsingDirectiveList">
    <Id>RCS0006</Id>
    <Title>Add blank line before using directive list.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[// Copyright ...
using System;
using System.Linq;

namespace N
{
}]]></Before>
        <After><![CDATA[// Copyright ...

using System;
using System.Linq;

namespace N
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddBlankLineBetweenAccessors">
    <Id>RCS0007</Id>
    <Title>Add blank line between accessors.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string P
{
    get
    {
        return _p;
    }
    set
    {
        _p = value;
    }
}]]></Before>
        <After><![CDATA[string P
{
    get
    {
        return _p;
    }

    set
    {
        _p = value;
    }
}]]></After>
      </Sample>
    </Samples>
    <Remarks>This rule does not enforce an blank line between two single-line accessors.</Remarks>
  </Analyzer>
  <Analyzer Identifier="AddBlankLineBetweenClosingBraceAndNextStatement">
    <Id>RCS0008</Id>
    <Title>Add blank line between closing brace and next statement.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
{
}
Foo();]]></Before>
        <After><![CDATA[if (x)
{
}

Foo();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddBlankLineBetweenDeclarationAndDocumentationComment">
    <Id>RCS0009</Id>
    <Title>Add blank line between declaration and documentation comment.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[object P1 { get; }
/// <summary>
/// ...
/// </summary>
object P2 { get; }]]></Before>
        <After><![CDATA[object P1 { get; }

/// <summary>
/// ...
/// </summary>
object P2 { get; }]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddBlankLineBetweenDeclarations">
    <Id>RCS0010</Id>
    <Title>Add blank line between declarations.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[class Foo
{
    void M1()
    {
    }
    void M2()
    {
    }
    /// <summary>
    /// ...
    /// </summary>
    void M3()
    {
    }
    string P1 { get; set; }
    [Obsolete]
    string P2 { get; set; }
}
enum Bar
{
    A = 0,
    /// <summary>
    /// ...
    /// </summary>
    B = 1,
    [Obsolete]
    C = 2,
}]]></Before>
        <After><![CDATA[class Foo
{
    void M1()
    {
    }

    void M2()
    {
    }

    /// <summary>
    /// ...
    /// </summary>
    void M3()
    {
    }

    string P1 { get; set; }

    [Obsolete]
    string P2 { get; set; }
}

enum Bar
{
    A = 0,

    /// <summary>
    /// ...
    /// </summary>
    B = 1,

    [Obsolete]
    C = 2,
}]]></After>
      </Sample>
    </Samples>
    <Remarks>This rule does not enforce an blank line between two single-line declaration.</Remarks>
  </Analyzer>
  <Analyzer Identifier="BlankLineBetweenSingleLineAccessors">
    <Id>RCS0011</Id>
    <Title>Add/remove blank line between single-line accessors.</Title>
    <MessageFormat>{0} blank line between single-line accessors.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string P
{
    get { return _p; }
    set { _p = value; }
}]]></Before>
        <After><![CDATA[string P
{
    get { return _p; }
    
    set { _p = value; }
}]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="blank_line_between_single_line_accessors" IsRequired="true" />
    </ConfigOptions>
    <Options>
      <Option Identifier="RemoveEmptyLineBetweenSingleLineAccessors">
        <Title>Remove empty line between single-line accessors.</Title>
        <Id>i</Id>
        <OptionKey>invert</OptionKey>
        <NewOptionKey>blank_line_between_single_line_accessors</NewOptionKey>
        <Kind>Invert</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[string P
{
    get { return _p; }

    set { _p = value; }
}]]></Before>
            <After><![CDATA[string P
{
    get { return _p; }
    set { _p = value; }
}]]></After>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="AddBlankLineBetweenSingleLineDeclarations">
    <Id>RCS0012</Id>
    <Title>Add blank line between single-line declarations.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[object P1 { get; }
object P2 { get; }]]></Before>
        <After><![CDATA[object P1 { get; }

object P2 { get; }]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddBlankLineBetweenSingleLineDeclarationsOfDifferentKind">
    <Id>RCS0013</Id>
    <Title>Add blank line between single-line declarations of different kind.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[object P { get; }
object this[int index] { get; }]]></Before>
        <After><![CDATA[object P { get; }

object this[int index] { get; }]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddBlankLineBetweenSwitchSections">
    <Id>RCS0014</Id>
    <Title>Add blank line between switch sections.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <ConfigOptions>
      <Option Key="blank_line_between_closing_brace_and_switch_section" />
    </ConfigOptions>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (x)
{
    case "a":
        return A();
    case "b":
        return B();
}
]]></Before>
        <After><![CDATA[switch (x)
{
    case "a":
        return A();

    case "b":
        return B();
}
]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="BlankLineBetweenUsingDirectives">
    <Id>RCS0015</Id>
    <Title>Add/remove blank line between using directives.</Title>
    <MessageFormat>{0} blank line between using directives.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[using System;
using Microsoft.CodeAnalysis;

namespace N
{
}]]></Before>
        <After><![CDATA[using System;

using Microsoft.CodeAnalysis;

namespace N
{
}]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="blank_line_between_using_directives" IsRequired="true" />
    </ConfigOptions>
    <Options>
      <Option Identifier="RemoveEmptyLineBetweenUsingDirectivesWithDifferentRootNamespace">
        <Title>Remove empty line between using directives with different root namespace.</Title>
        <MessageFormat>Remove empty line between using directives.</MessageFormat>
        <Id>i</Id>
        <OptionKey>invert</OptionKey>
        <NewOptionKey>blank_line_between_using_directives</NewOptionKey>
        <Kind>Invert</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[using System;

using Microsoft.CodeAnalysis;

namespace N
{
}]]></Before>
            <After><![CDATA[using System;
using Microsoft.CodeAnalysis;

namespace N
{
}]]></After>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="PutAttributeListOnItsOwnLine">
    <Id>RCS0016</Id>
    <Title>Put attribute list on its own line.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[enum Foo
{
    A,
    [Obsolete] B,
    C,
}]]></Before>
        <After><![CDATA[enum Foo
{
    A,
    [Obsolete]
    B,
    C,
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddNewLineAfterBinaryOperatorInsteadOfBeforeIt2" IsObsolete="true">
    <Id>RCS0017</Id>
    <Title>Add new line after binary operator instead of before it.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x
    && y
    && z)
{
}]]></Before>
        <After><![CDATA[if (x &&
    y &&
    z)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddNewLineAfterConditionalOperatorInsteadOfBeforeIt2" IsObsolete="true">
    <Id>RCS0018</Id>
    <Title>Add new line after conditional operator instead of before it.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var y = (x)
    ? Foo()
    : Bar();]]></Before>
        <After><![CDATA[var y = (x) ?
     Foo() :
     Bar();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddNewLineAfterExpressionBodyArrowInsteadOfBeforeIt2" IsObsolete="true">
    <Id>RCS0019</Id>
    <Title>Add new line after expression body arrow instead of before it.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[object Foo()
    => null;]]></Before>
        <After><![CDATA[object Foo() =>
    null;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="FormatAccessorBraces">
    <Id>RCS0020</Id>
    <Title>Format accessor's braces on a single line or multiple lines.</Title>
    <MessageFormat>Format braces on {0}.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <ConfigOptions>
      <Option Key="accessor_braces_style" IsRequired="true" />
    </ConfigOptions>
    <Samples>
      <Sample>
        <Before><![CDATA[string Foo
{
    get { return _foo; }
}]]></Before>
        <After><![CDATA[string Foo
{
    get
    {
        return _foo;
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="FormatBlockBraces">
    <Id>RCS0021</Id>
    <Title>Format block's braces on a single line or multiple lines.</Title>
    <MessageFormat>Format braces on {0}.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <ConfigOptions>
      <Option Key="block_braces_style" IsRequired="true" />
    </ConfigOptions>
    <Samples>
      <Sample>
        <Before><![CDATA[void Foo() { Bar(); }]]></Before>
        <After><![CDATA[void Foo()
{
    Bar();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddNewLineAfterOpeningBraceOfEmptyBlock">
    <Id>RCS0022</Id>
    <Title>Add new line after opening brace of empty block.</Title>
    <MessageFormat>([deprecated] Use RCS0021 instead) Format braces on a single line.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[void Foo()
{ }]]></Before>
        <After><![CDATA[void Foo()
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="FormatTypeDeclarationBraces">
    <Id>RCS0023</Id>
    <Title>Format type declaration's braces.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[interface IFoo
{ }]]></Before>
        <After><![CDATA[interface IFoo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddNewLineAfterSwitchLabel">
    <Id>RCS0024</Id>
    <Title>Add new line after switch label.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (x)
{
    case "a": return A();
    case "b": return B();
}]]></Before>
        <After><![CDATA[switch (x)
{
    case "a":
        return A();
    case "b":
        return B();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="PutFullAccessorOnItsOwnLine">
    <Id>RCS0025</Id>
    <Title>Put full accessor on its own line.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string Foo { get { return _foo; } set { _foo = value; } }]]></Before>
        <After><![CDATA[string Foo
{
    get { return _foo; }
    set { _foo = value; }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="PlaceNewLineAfterOrBeforeBinaryOperator">
    <Id>RCS0027</Id>
    <Title>Place new line after/before binary operator.</Title>
    <MessageFormat>Place new line {0} binary operator.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x &&
    y &&
    z)
{
}]]></Before>
        <After><![CDATA[if (x
    && y
    && z)
{
}]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="binary_operator_new_line" IsRequired="true" />
    </ConfigOptions>
    <Options>
      <Option Identifier="AddNewLineAfterBinaryOperatorInsteadOfBeforeIt">
        <Title>Add new line after binary operator instead of before it.</Title>
        <Id>i</Id>
        <OptionKey>invert</OptionKey>
        <NewOptionKey>binary_operator_new_line</NewOptionKey>
        <Kind>Invert</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[if (x
    && y
    && z)
{
}]]></Before>
            <After><![CDATA[if (x &&
    y &&
    z)
{
}]]></After>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="PlaceNewLineAfterOrBeforeConditionalOperator">
    <Id>RCS0028</Id>
    <Title>Place new line after/before '?:' operator.</Title>
    <MessageFormat>Place new line {0} operator.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var y = x ?
    Foo() :
    Bar();]]></Before>
        <After><![CDATA[var y = x
    ? Foo()
    : Bar();]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="conditional_operator_new_line" IsRequired="true" />
    </ConfigOptions>
    <Options>
      <Option Identifier="AddNewLineAfterConditionalOperatorInsteadOfBeforeIt">
        <Title>Add new line after conditional operator instead of before it.</Title>
        <Id>i</Id>
        <OptionKey>invert</OptionKey>
        <NewOptionKey>conditional_operator_new_line</NewOptionKey>
        <Kind>Invert</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[var y = x
    ? Foo()
    : Bar();]]></Before>
            <After><![CDATA[var y = x ?
    Foo() :
    Bar();]]></After>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="PutConstructorInitializerOnItsOwnLine">
    <Id>RCS0029</Id>
    <Title>Put constructor initializer on its own line.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[Foo(object p1, object p2) : base(p1)
{
    P2 = p2;
}]]></Before>
        <After><![CDATA[Foo(object p1, object p2)
    : base(p1)
{
    P2 = p2;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddNewLineBeforeEmbeddedStatement">
    <Id>RCS0030</Id>
    <Title>Add new line before embedded statement.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x) Foo();]]></Before>
        <After><![CDATA[if (x)
    Foo();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="PutEnumMemberOnItsOwnLine">
    <Id>RCS0031</Id>
    <Title>Put enum member on its own line.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[enum Foo { A, B, C, }]]></Before>
        <After><![CDATA[enum Foo
{
    A,
    B,
    C,
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="PlaceNewLineAfterOrBeforeArrowToken">
    <Id>RCS0032</Id>
    <Title>Place new line after/before arrow token.</Title>
    <MessageFormat>Place new line {0} arrow token.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[object Foo() =>
    null;]]></Before>
        <After><![CDATA[object Foo()
    => null;]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="arrow_token_new_line" IsRequired="true" />
    </ConfigOptions>
    <Options>
      <Option Identifier="AddNewLineAfterExpressionBodyArrowInsteadOfBeforeIt">
        <Title>Add new line after expression body arrow instead of before it.</Title>
        <Id>i</Id>
        <OptionKey>invert</OptionKey>
        <NewOptionKey>arrow_token_new_line</NewOptionKey>
        <Kind>Invert</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[object Foo()
    => null;]]></Before>
            <After><![CDATA[object Foo() =>
    null;]]></After>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="AddNewLineBeforeStatement">
    <Id>RCS0033</Id>
    <Title>Add new line before statement.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[Foo(); Bar();]]></Before>
        <After><![CDATA[Foo();
Bar();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="PutTypeParameterConstraintOnItsOwnLine">
    <Id>RCS0034</Id>
    <Title>Put type parameter constraint on its own line.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[class Foo<T1, T2> where T1 : struct where T2 : struct
{
}]]></Before>
        <After><![CDATA[class Foo<T1, T2>
    where T1 : struct
    where T2 : struct
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveEmptyLineBetweenSingleLineAccessors2" IsObsolete="true">
    <Id>RCS0035</Id>
    <Title>Remove empty line between single-line accessors.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string P
{
    get { return _p; }

    set { _p = value; }
}]]></Before>
        <After><![CDATA[string P
{
    get { return _p; }
    set { _p = value; }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveBlankLineBetweenSingleLineDeclarationsOfSameKind">
    <Id>RCS0036</Id>
    <Title>Remove blank line between single-line declarations of same kind.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Samples>
        <Sample>
          <Before><![CDATA[object P1 { get; }

object P2 { get; }]]></Before>
          <After><![CDATA[object P1 { get; }
object P2 { get; }]]></After>
        </Sample>
      </Samples>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveEmptyLineBetweenUsingDirectivesWithDifferentRootNamespace2" IsObsolete="true">
    <Id>RCS0037</Id>
    <Title>Remove empty line between using directives with different root namespace.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[using System;

using Microsoft.CodeAnalysis;

namespace N
{
}]]></Before>
        <After><![CDATA[using System;
using Microsoft.CodeAnalysis;

namespace N
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveBlankLineBetweenUsingDirectivesWithSameRootNamespace">
    <Id>RCS0038</Id>
    <Title>Remove blank line between using directives with same root namespace.</Title>
    <MessageFormat>([deprecated] Use RCS0015 instead) Remove blank line between using directives.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[using System;

using System.Linq;

namespace N
{
}]]></Before>
        <After><![CDATA[using System;
using System.Linq;

namespace N
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveNewLineBeforeBaseList">
    <Id>RCS0039</Id>
    <Title>Remove new line before base list.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[class Foo
    : Bar
{
}]]></Before>
        <After><![CDATA[class Foo : Bar
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveNewLineBetweenClosingBraceAndWhileKeyword2" IsObsolete="true">
    <Id>RCS0040</Id>
    <Title>Remove new line between closing brace and 'while' keyword.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[do
{
    Foo();
}
while (x);]]></Before>
        <After><![CDATA[do
{
    Foo();
} while (x);]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveNewLineBetweenIfKeywordAndElseKeyword">
    <Id>RCS0041</Id>
    <Title>Remove new line between 'if' keyword and 'else' keyword.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
{
    Foo();
}
else
if (y)
{
    Bar();
}]]></Before>
        <After><![CDATA[if (x)
{
    Foo();
}
else if (y)
{
    Bar();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="PutAutoAccessorsOnSingleLine">
    <Id>RCS0042</Id>
    <Title>Put auto-accessors on a single line.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string Foo
{
    get;
    set;
}]]></Before>
        <After><![CDATA[string Foo { get; set; }]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="FormatAccessorBracesOnSingleLineWhenExpressionIsOnSingleLine">
    <Id>RCS0043</Id>
    <Title>Format accessor's braces on a single line when expression is on single line.</Title>
    <MessageFormat>([deprecated] Use RCS0020 with option 'roslynator_accessor_braces_style = single_line_when_expression_is_on_single_line) Format braces on a single line.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string Foo
{
    get
    {
        return _foo;
    }
    set
    {
        _foo = value;
    }
}]]></Before>
        <After><![CDATA[string Foo
{
    get { return _foo; }
    set { _foo = value; }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseCarriageReturnAndLinefeedAsNewLine">
    <Id>RCS0044</Id>
    <Title>Use carriage return + linefeed as new line.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
  </Analyzer>
  <Analyzer Identifier="UseLinefeedAsNewLine">
    <Id>RCS0045</Id>
    <Title>Use linefeed as new line.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
  </Analyzer>
  <Analyzer Identifier="UseSpacesInsteadOfTab">
    <Id>RCS0046</Id>
    <Title>Use spaces instead of tab.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
  </Analyzer>
  <Analyzer Identifier="WrapAndIndentEachNodeInList">
    <Id>RCS0047</Id>
    <Title>[deprecated] Wrap and indent each node in list.</Title>
    <MessageFormat>[deprecated] Use analyzer RCS0053 instead.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Summary>This analyzer has been deprecated. Use analyzer [RCS0053](RCS0053.md) instead.</Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[void M(object p1,
    object p2
    object p3) 
{
}]]></Before>
        <After><![CDATA[void M(
    object p1,
    object p2,
    object p3) 
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[void M(
    object p1,
    object p2, object p3) 
{
}]]></Before>
        <After><![CDATA[void M(
    object p1,
    object p2,
    object p3) 
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="PutInitializerOnSingleLine">
    <Id>RCS0048</Id>
    <Title>Put initializer on a single line.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var dic = new Dictionary<int, string>()
{
    { 0, "0" }
};]]></Before>
        <After><![CDATA[var dic = new Dictionary<int, string>() { { 0, "0" } };]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddBlankLineAfterTopComment">
    <Id>RCS0049</Id>
    <Title>Add blank line after top comment.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[// Copyright ...
using System;

namespace Foo
{
}]]></Before>
        <After><![CDATA[// Copyright ...

using System;

namespace Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddBlankLineBeforeTopDeclaration">
    <Id>RCS0050</Id>
    <Title>Add blank line before top declaration.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[using System;
namespace Foo
{
}]]></Before>
        <After><![CDATA[using System;

namespace Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddOrRemoveNewLineBeforeWhileInDoStatement">
    <Id>RCS0051</Id>
    <Title>Add/remove new line before 'while' in 'do' statement.</Title>
    <MessageFormat>{0} new line before 'while' in 'do' statement.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[do
{
    Foo();
} while (x);]]></Before>
        <After><![CDATA[do
{
    Foo();
}
while (x);]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="new_line_before_while_in_do_statement" IsRequired="true" />
    </ConfigOptions>
    <Options>
      <Option Identifier="RemoveNewLineBetweenClosingBraceAndWhileKeyword">
        <Title>Remove new line between closing brace and 'while' keyword.</Title>
        <Id>i</Id>
        <OptionKey>invert</OptionKey>
        <NewOptionKey>new_line_before_while_in_do_statement</NewOptionKey>
        <Kind>Invert</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[do
{
    Foo();
}
while (x);]]></Before>
            <After><![CDATA[do
{
    Foo();
} while (x);]]></After>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="PlaceNewLineAfterOrBeforeEqualsToken">
    <Id>RCS0052</Id>
    <Title>Place new line after/before equals token.</Title>
    <MessageFormat>Place new line {0} equals token.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s =
    new string(' ', 4);]]></Before>
        <After><![CDATA[string s
    = new string(' ', 4);]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="equals_token_new_line" IsRequired="true" />
    </ConfigOptions>
    <Options>
      <Option Identifier="AddNewLineAfterEqualsSignInsteadOfBeforeIt">
        <Title>Add new line after equals sign instead of before it.</Title>
        <Id>i</Id>
        <OptionKey>invert</OptionKey>
        <NewOptionKey>equals_token_new_line</NewOptionKey>
        <Kind>Invert</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[string s
    = new string(' ', 4);]]></Before>
            <After><![CDATA[string s =
    new string(' ', 4);]]></After>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="FixFormattingOfList">
    <Id>RCS0053</Id>
    <Title>Fix formatting of a list.</Title>
    <MessageFormat>Fix formatting of {0}.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Summary>
      This analyzer:
* fixes indentation of argument/parameter list and similar lists
* formats each item in a multi-line list on a separate line

Following formats are considered as valid (for a parameter list):
```cs
void M(object x, object y)
{
}
```
```cs
void M(
    object x, object y)
{
}
```
```cs
void M(
    object x,
    object y)
{
}
```
</Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[void M(
    object x,
        object y)
{
}]]></Before>
        <After><![CDATA[void M(
    object x,
    object y)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[void M(object x,
    object y)
{
}]]></Before>
        <After><![CDATA[void M(
    object x,
    object y)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[void M(object x,
       object y)
{
}]]></Before>
        <After><![CDATA[void M(
    object x,
    object y)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[void M(
    object x,
    object y, object z)
{
}]]></Before>
        <After><![CDATA[void M(
    object x,
    object y,
    object z)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="FixFormattingOfCallChain">
    <Id>RCS0054</Id>
    <Title>Fix formatting of a call chain.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Summary>This analyzer:
* fixes indentation of multi-line call chain
* formats each call on a separate line
</Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[return [|x.M1()
    .M2().M3()|];]]></Before>
        <After><![CDATA[return [|x.M1()
    .M2()
    .M3()|];]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[return [|x.M1()
.M2()
.M3()|];]]></Before>
        <After><![CDATA[return [|x.M1()
    .M2()
    .M3()|];]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="FixFormattingOfBinaryExpressionChain">
    <Id>RCS0055</Id>
    <Title>Fix formatting of a binary expression chain.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Summary>This analyzer:
 * fixes indentation of multi-line binary expression chain
 * formats each expression on a separate line
 </Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x && y
    && z)
{
}]]></Before>
        <After><![CDATA[if (x
    && y
    && z)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (x
&& y
&& z)
{
}]]></Before>
        <After><![CDATA[if (x
    && y
    && z)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="LineIsTooLong">
    <Id>RCS0056</Id>
    <Title>A line is too long.</Title>
    <MessageFormat>A line is too long ({0} characters).</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Summary>This analyzer reports any line that is longer than maximal length.
    
Default maximal length is 140.</Summary>
    <ConfigOptions>
      <Option Key="max_line_length" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer Identifier="NormalizeWhitespaceAtBeginningOfFile">
    <Id>RCS0057</Id>
    <Title>Normalize whitespace at the beginning of a file.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Summary>This analyzer enforces no whitespace at the beginning of a file.</Summary>
  </Analyzer>
  <Analyzer Identifier="NormalizeWhitespaceAtEndOfFile">
    <Id>RCS0058</Id>
    <Title>Normalize whitespace at the end of a file.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Summary>This analyzer enforces:
* new line at the end of a file
* no new line at the end of a file if the option `roslynator.prefer_new_line_at_end_of_file` is set to `false`.</Summary>
    <ConfigOptions>
      <Option Key="new_line_at_end_of_file" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer Identifier="PlaceNewLineAfterOrBeforeNullConditionalOperator">
    <Id>RCS0059</Id>
    <Title>Place new line after/before null-conditional operator.</Title>
    <MessageFormat>Place new line {0} null-conditional operator.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[items
    .Select(selector)
    .FirstOrDefault()
    ?.ToString()
    ]]></Before>
        <After><![CDATA[items
    .Select(selector)
    .FirstOrDefault()?
    .ToString()
    ]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="null_conditional_operator_new_line" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer Identifier="BlankLineAfterFileScopedNamespaceDeclaration">
    <Id>RCS0060</Id>
    <Title>Add/remove line after file scoped namespace declaration.</Title>
    <MessageFormat>{0} line after file scoped namespace declaration.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <MinLanguageVersion>10.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[namespace A.B
public class C
{
}]]></Before>
        <After><![CDATA[namespace A.B

public class C
{
}]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="blank_line_after_file_scoped_namespace_declaration" IsRequired="true" />
    </ConfigOptions>
    <Links>
      <Link>
        <Url>https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-10.0/file-scoped-namespaces</Url>
        <Text>File Scoped Namespaces</Text>
      </Link>
    </Links>
  </Analyzer>
  <Analyzer Identifier="AddBracesWhenExpressionSpansOverMultipleLines">
    <Id>RCS1001</Id>
    <Title>Add braces (when expression spans over multiple lines).</Title>
    <MessageFormat>Add braces to {0} (when expression spans over multiple lines).</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
    Foo(
        x,
        y);]]></Before>
        <After><![CDATA[if (condition)
{
    Foo(
        x,
        y);
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveBraces">
    <Id>RCS1002</Id>
    <Title>Remove braces.</Title>
    <MessageFormat>Remove braces from {0}.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
{
    Foo();
}]]></Before>
        <After><![CDATA[if (condition)
    Foo();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddBracesToIfElseWhenExpressionSpansOverMultipleLines">
    <Id>RCS1003</Id>
    <Title>Add braces to if-else (when expression spans over multiple lines).</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
    WhenTrue(
        x,
        y);
else
    WhenFalse(
        x,
        y);]]></Before>
        <After><![CDATA[if (condition)
{
    WhenTrue(
        x,
        y);
}
else
{
    WhenFalse(
        x,
        y);
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveBracesFromIfElse">
    <Id>RCS1004</Id>
    <Title>Remove braces from if-else.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
{
    WhenTrue();
}
else
{
    WhenFalse();
}]]></Before>
        <After><![CDATA[if (condition)
    WhenTrue();
else
    WhenFalse();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="SimplifyNestedUsingStatement">
    <Id>RCS1005</Id>
    <Title>Simplify nested using statement.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[using (var fs = new FileStream("path", FileMode.OpenOrCreate))
{
    using (var sr = new StreamReader(fs))
    {
    }
}]]></Before>
        <After><![CDATA[using (var fs = new FileStream("path", FileMode.OpenOrCreate))
using (var sr = new StreamReader(fs))
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="MergeElseWithNestedIf">
    <Id>RCS1006</Id>
    <Title>Merge 'else' with nested 'if'.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition1)
{
    Foo1();
}
else
{
    if (condition2)
    {
        Foo2();
    }
}]]></Before>
        <After><![CDATA[if (condition1)
{
    Foo1();
}
else if (condition2)
{
    Foo2();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddBraces">
    <Id>RCS1007</Id>
    <Title>Add braces.</Title>
    <MessageFormat>Add braces to {0}.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
    Foo();]]></Before>
        <After><![CDATA[if (condition)
{
    Foo();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseExplicitTypeInsteadOfVarWhenTypeIsNotObvious">
    <Id>RCS1008</Id>
    <Title>Use explicit type instead of 'var' (when the type is not obvious).</Title>
    <MessageFormat>Use explicit type instead of 'var'.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var s = GetValue();]]></Before>
        <After><![CDATA[string s = GetValue();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseExplicitTypeInsteadOfVarInForEach">
    <Id>RCS1009</Id>
    <Title>Use explicit type instead of 'var' (foreach variable).</Title>
    <MessageFormat>Use explicit type instead of 'var'.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var items = new List<string>();

// ...

foreach (var item in items)
{
}]]></Before>
        <After><![CDATA[foreach (string item in items)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseVarInsteadOfExplicitTypeWhenTypeIsObvious">
    <Id>RCS1010</Id>
    <Title>Use 'var' instead of explicit type (when the type is obvious).</Title>
    <MessageFormat>Use 'var' instead of explicit type.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[Foo foo = new Foo();]]></Before>
        <After><![CDATA[var foo = new Foo();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseExplicitTypeInsteadOfVarWhenTypeIsObvious">
    <Id>RCS1012</Id>
    <Title>Use explicit type instead of 'var' (when the type is obvious).</Title>
    <MessageFormat>Use explicit type instead of 'var'.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var foo = new Foo();]]></Before>
        <After><![CDATA[Foo foo = new Foo();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UsePredefinedType">
    <Id>RCS1013</Id>
    <Title>Use predefined type.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[String s = null;]]></Before>
        <After><![CDATA[string s = null;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseExplicitlyOrImplicitlyTypedArray">
    <Id>RCS1014</Id>
    <Title>Use explicitly/implicitly typed array.</Title>
    <MessageFormat>Use {0} typed array.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var items = new[] { "a", B };]]></Before>
        <After><![CDATA[var items = new string[] { "a", B };]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="array_creation_type_style" IsRequired="true" />
    </ConfigOptions>
    <Options>
      <Option Identifier="UseImplicitlyTypedArrayWhenTypeIsObvious">
        <Title>Use implicitly typed array (when type is obvious).</Title>
        <Id>a</Id>
        <OptionKey>use_implicit_type_when_obvious</OptionKey>
        <NewOptionKey>array_creation_style.type</NewOptionKey>
        <Kind>Change</Kind>
        <SupportsFadeOut>true</SupportsFadeOut>
        <Samples>
          <Sample>
            <Before><![CDATA[var items = new string[] { "a", "b" };]]></Before>
            <After><![CDATA[var items = new[] { "a", "b" };]]></After>
          </Sample>
        </Samples>
      </Option>
      <Option Identifier="UseImplicitlyTypedArray">
        <Title>Use implicitly typed array.</Title>
        <Id>i</Id>
        <OptionKey>invert</OptionKey>
        <NewOptionKey>array_creation_style.type</NewOptionKey>
        <Kind>Invert</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[var items = new string[] { A, B };]]></Before>
            <After><![CDATA[var items = new[] { A, B };]]></After>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="UseNameOfOperator">
    <Id>RCS1015</Id>
    <Title>Use nameof operator.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <MinLanguageVersion>6.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[public void Foo(object parameter)
{
    if (parameter == null)
    {
        throw new ArgumentNullException("parameter", "message");
    }
}]]></Before>
        <After><![CDATA[public void Foo(object parameter)
{
    if (parameter == null)
    {
        throw new ArgumentNullException(nameof(parameter), "message");
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseBlockBodyOrExpressionBody">
    <Id>RCS1016</Id>
    <Title>Use block body or expression body.</Title>
    <MessageFormat>Use {0} body.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <MinLanguageVersion>6.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[public string Foo()
{
    return "";
}]]></Before>
        <After><![CDATA[public string Foo() => "";]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="body_style" IsRequired="true" />
      <Option Key="use_block_body_when_declaration_spans_over_multiple_lines" IsRequired="true" />
      <Option Key="use_block_body_when_expression_spans_over_multiple_lines" IsRequired="true" />
    </ConfigOptions>
    <Options>
      <Option Identifier="ConvertExpressionBodyToBlockBodyWhenExpressionIsMultiLine">
        <Title>Convert expression body to block body when expression is multi-line.</Title>
        <Id>a</Id>
        <OptionKey>use_block_body_when_expression_is_multiline</OptionKey>
        <NewOptionKey>prefer_block_body_when_expression_spans_over_multiple_lines</NewOptionKey>
        <Kind>Change</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[public string[] Foo() => new string[]
{
    "a",
    "b",
    "c"
};]]></Before>
            <After><![CDATA[public string[] Foo()
{
    return new string[]
    {
        "a",
        "b",
        "c"
    };
}]]></After>
          </Sample>
        </Samples>
      </Option>
      <Option Identifier="ConvertExpressionBodyToBlockBodyWhenDeclarationIsMultiLine">
        <Title>Convert expression body to block body when declaration is multi-line.</Title>
        <Id>b</Id>
        <OptionKey>use_block_body_when_declaration_is_multiline</OptionKey>
        <NewOptionKey>prefer_block_body_when_declaration_spans_over_multiple_lines</NewOptionKey>
        <Kind>Change</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[public string[] Foo(
    string a,
    string b,
    string c) => new string[] { a, b, c };]]></Before>
            <After><![CDATA[public string[] Foo(
    string a,
    string b,
    string c)
{
    return new string[] { a, b, c };
}]]></After>
          </Sample>
        </Samples>
      </Option>
      <Option Identifier="ConvertExpressionBodyToBlockBody">
        <Title>Convert expression body to block body.</Title>
        <Id>i</Id>
        <OptionKey>invert</OptionKey>
        <NewOptionKey>body_style</NewOptionKey>
        <Kind>Invert</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[public string Foo() => null;]]></Before>
            <After><![CDATA[public string Foo()
{
    return null;
}
]]></After>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="AvoidMultilineExpressionBody" IsObsolete="true">
    <Id>RCS1017</Id>
    <Title>[deprecated] Avoid multiline expression body.</Title>
    <MessageFormat>[deprecated] Use analyzer RCS1016a instead.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Summary>This analyzer has been deprecated. Use EditorConfig option `roslynator.prefer_block_body_when_expression_spans_over_multiple_lines = true` instead.</Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[public string[] Foo() => new string[]
{
    "a",
    "b",
    "c"
};]]></Before>
        <After><![CDATA[public string[] Foo()
{
    return new string[]
    {
        "a",
        "b",
        "c"
    };
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddOrRemoveAccessibilityModifiers">
    <Id>RCS1018</Id>
    <Title>Add/remove accessibility modifiers.</Title>
    <MessageFormat>{0} accessibility modifiers.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[class Foo
{
    void Bar()
    {
    }
}]]></Before>
        <After><![CDATA[internal class Foo
{
    private void Bar()
    {
    }
}]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="accessibility_modifiers" IsRequired="true" />
    </ConfigOptions>
    <Options>
      <Option Identifier="RemoveAccessibilityModifiers">
        <Title>Remove accessibility modifiers.</Title>
        <Id>i</Id>
        <OptionKey>invert</OptionKey>
        <NewOptionKey>accessibility_modifiers</NewOptionKey>
        <Kind>Invert</Kind>
        <SupportsFadeOut>true</SupportsFadeOut>
        <Samples>
          <Sample>
            <Before><![CDATA[internal class Foo
{
    private void Bar()
    {
    }
}]]></Before>
            <After><![CDATA[class Foo
{
    void Bar()
    {
    }
}]]></After>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="OrderModifiers">
    <Id>RCS1019</Id>
    <Title>Order modifiers.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[private readonly static object _f;

internal protected class Foo
{
}]]></Before>
        <After><![CDATA[private static readonly object _f;

protected internal class Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="SimplifyNullableOfT">
    <Id>RCS1020</Id>
    <Title>Simplify Nullable&lt;T&gt; to T?.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[Nullable<int> x = null;]]></Before>
        <After><![CDATA[int? x = null;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="ConvertLambdaExpressionBodyToExpressionBody">
    <Id>RCS1021</Id>
    <Title>Convert lambda expression body to expression body.</Title>
    <MessageFormat>Use expression-bodied lambda.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = items.Select(f =>
{
    return f.ToString();
});]]></Before>
        <After><![CDATA[var x = items.Select(f => f.ToString());]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="SimplifyLambdaExpressionParameterList" IsObsolete="true">
    <Id>RCS1022</Id>
    <Title>Simplify lambda expression parameter list.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
  </Analyzer>
  <Analyzer Identifier="FormatEmptyBlock" IsObsolete="true">
    <Id>RCS1023</Id>
    <Title>Format empty block.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[void Foo()
{ }]]></Before>
        <After><![CDATA[void Foo()
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="FormatAccessorList" IsObsolete="true">
    <Id>RCS1024</Id>
    <Title>Format accessor list.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string Foo { get { return _foo; } set { _foo = value; } }]]></Before>
        <After><![CDATA[string Foo
{
    get { return _foo; }
    set { _foo = value; }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddNewLineBeforeEnumMember" IsObsolete="true">
    <Id>RCS1025</Id>
    <Title>Add new line before enum member.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[enum Foo { A, B, C, }]]></Before>
        <After><![CDATA[enum Foo
{
    A,
    B,
    C,
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddNewLineBeforeStatement" IsObsolete="true">
    <Id>RCS1026</Id>
    <Title>Add new line before statement.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[Foo(); Bar();]]></Before>
        <After><![CDATA[Foo();
Bar();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddNewLineBeforeEmbeddedStatement" IsObsolete="true">
    <Id>RCS1027</Id>
    <Title>Add new line before embedded statement.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x) Foo();]]></Before>
        <After><![CDATA[if (x)
{
    Foo();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddNewLineAfterSwitchLabel" IsObsolete="true">
    <Id>RCS1028</Id>
    <Title>Add new line after switch label.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (x)
{
    case "a": return Foo();
    case "b": return Bar();
}]]></Before>
        <After><![CDATA[switch (x)
{
    case "a":
        return Foo();
    case "b":
        return Bar();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="FormatBinaryOperatorOnNextLine" IsObsolete="true">
    <Id>RCS1029</Id>
    <Title>Format binary operator on next line.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x &&
    y &&
    z)
{
}]]></Before>
        <After><![CDATA[if (x
    && y
    && z)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddEmptyLineAfterEmbeddedStatement" IsObsolete="true">
    <Id>RCS1030</Id>
    <Title>Add empty line after embedded statement.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
    Foo();
Bar();]]></Before>
        <After><![CDATA[if (x)
    Foo();

Bar();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveUnnecessaryBracesInSwitchSection">
    <Id>RCS1031</Id>
    <Title>Remove unnecessary braces in switch section.</Title>
    <MessageFormat>Remove unnecessary braces.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (x)
{
    case "a":
        {
            M();
            break;
        }
    case "b":
        break;
}
]]></Before>
        <After><![CDATA[switch (x)
{
    case "a":
        M();
        break;

    case "b":
        break;
}
]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantParentheses">
    <Id>RCS1032</Id>
    <Title>Remove redundant parentheses.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[if ((x))
{
    return (y);
}]]></Before>
        <After><![CDATA[if (x)
{
    return y;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantBooleanLiteral">
    <Id>RCS1033</Id>
    <Title>Remove redundant boolean literal.</Title>
    <MessageFormat>Remove redundant '{0}'.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[if (f == true)
{
}

if (f != false)
{
}]]></Before>
        <After><![CDATA[if (f)
{
}

if (f)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantSealedModifier">
    <Id>RCS1034</Id>
    <Title>Remove redundant 'sealed' modifier.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public sealed class Foo
{
    public sealed override string ToString()
    {
        return "";
    }
}]]></Before>
        <After><![CDATA[public override string ToString()
{
    return "";
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantCommaInInitializer">
    <Id>RCS1035</Id>
    <Title>Remove redundant comma in initializer.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public void Foo()
{
    var arr = new string[] { "a", "b", "c", };
}]]></Before>
        <After><![CDATA[public void Foo()
{
    var arr = new string[] { "a", "b", "c" };
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveUnnecessaryBlankLine">
    <Id>RCS1036</Id>
    <Title>Remove unnecessary blank line.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{

    private string _f;


    public bool Bar()
    {

        return false;

    }

}]]></Before>
        <After><![CDATA[public class Foo
{
    private string _f;

    public bool Bar()
    {
        return false;
    }
}]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="blank_line_between_closing_brace_and_switch_section" />
    </ConfigOptions>
    <Options>
      <Option Identifier="RemoveEmptyLineBetweenClosingBraceAndSwitchSection">
        <Id>a</Id>
        <Title>Remove empty line between closing brace and switch section.</Title>
        <OptionKey>remove_empty_line_between_closing_brace_and_switch_section</OptionKey>
        <NewOptionKey>blank_line_between_closing_brace_and_switch_section</NewOptionKey>
        <Kind>Enable</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[switch (x)
{
    case "a":
        {
            M();
            break;
        }
            
    case "b":
        break;
}
    ]]></Before>
            <After><![CDATA[switch (x)
{
    case "a":
        {
            M();
            break;
        }
    case "b":
        break;
}
    ]]></After>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="RemoveTrailingWhitespace">
    <Id>RCS1037</Id>
    <Title>Remove trailing white-space.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer Identifier="RemoveEmptyStatement">
    <Id>RCS1038</Id>
    <Title>Remove empty statement.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public void Foo()
{
    ;
}]]></Before>
        <After><![CDATA[public void Foo()
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveArgumentListFromAttribute">
    <Id>RCS1039</Id>
    <Title>Remove argument list from attribute.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[[Obsolete()]
public void Foo()
{
}]]></Before>
        <After><![CDATA[[Obsolete]
public void Foo()
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveEmptyElseClause">
    <Id>RCS1040</Id>
    <Title>Remove empty 'else' clause.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
{
    Foo();
}
else
{
}]]></Before>
        <After><![CDATA[if (condition)
{
    Foo();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveEmptyInitializer">
    <Id>RCS1041</Id>
    <Title>Remove empty initializer.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[var items = new List<object>() { };]]></Before>
        <After><![CDATA[var items = new List<object>();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveEnumDefaultUnderlyingType">
    <Id>RCS1042</Id>
    <Title>Remove enum default underlying type.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public enum Foo : int
{
}]]></Before>
        <After><![CDATA[public enum Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemovePartialModifierFromTypeWithSinglePart">
    <Id>RCS1043</Id>
    <Title>Remove 'partial' modifier from type with a single part.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public partial class Foo
{
}]]></Before>
        <After><![CDATA[public class Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveOriginalExceptionFromThrowStatement">
    <Id>RCS1044</Id>
    <Title>Remove original exception from throw statement.</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[try
{
    Foo();
}
catch (Exception ex)
{
    throw ex;
}]]></Before>
        <After><![CDATA[try
{
    Foo();
}
catch (Exception ex)
{
    throw;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RenamePrivateFieldToCamelCaseWithUnderscore" IsObsolete="true">
    <Id>RCS1045</Id>
    <Title>Rename private field to camel case with underscore.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[private string f;]]></Before>
        <After><![CDATA[private string _f;]]></After>
      </Sample>
    </Samples>
    <Options>
      <Option Identifier="DoNotRenamePrivateStaticFieldToCamelCaseWithUnderscore">
        <Title>Do not rename private static field to camel case with underscore.</Title>
        <Id>a</Id>
        <OptionKey>suppress_when_field_is_static</OptionKey>
        <Kind>Disable</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[private static readonly string f;]]></Before>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="AsynchronousMethodNameShouldEndWithAsync">
    <Id>RCS1046</Id>
    <Title>Asynchronous method name should end with 'Async'.</Title>
    <MessageFormat>Add suffix 'Async' to asynchronous method name.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public static async Task<bool> Foo()
{
    return await Task.FromResult(false);
}]]></Before>
        <After><![CDATA[public static async Task<bool> FooAsync()
{
    return await Task.FromResult(false);
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="NonAsynchronousMethodNameShouldNotEndWithAsync">
    <Id>RCS1047</Id>
    <Title>Non-asynchronous method name should not end with 'Async'.</Title>
    <MessageFormat>Remove suffix 'Async' from non-asynchronous method name.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[public void FooAsync()
{
}]]></Before>
        <After><![CDATA[public void Foo()
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseLambdaExpressionInsteadOfAnonymousMethod">
    <Id>RCS1048</Id>
    <Title>Use lambda expression instead of anonymous method.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = items.Select(delegate (object f)
{
    return f.ToString();
});]]></Before>
        <After><![CDATA[var x = items.Select((object f) =>
{
    return f.ToString();
});]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="SimplifyBooleanComparison">
    <Id>RCS1049</Id>
    <Title>Simplify boolean comparison.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[bool f = false;

// ...

if (f == false)
{
}

if (f != true)
{
}]]></Before>
        <After><![CDATA[if (!f)
{
}

if (!f)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="IncludeParenthesesWhenCreatingNewObject">
    <Id>RCS1050</Id>
    <Title>Include/omit parentheses when creating new object.</Title>
    <MessageFormat>{0} parentheses when creating new object.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[var items = new List<string> { "a", "b", "c"  };]]></Before>
        <After><![CDATA[var items = new List<string>() { "a", "b", "c"  };]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="object_creation_parentheses_style" IsRequired="true" />
    </ConfigOptions>
    <Options>
      <Option Identifier="RemoveParenthesesWhenCreatingNewObject">
        <Title>Remove parentheses when creating new object.</Title>
        <Id>i</Id>
        <OptionKey>invert</OptionKey>
        <NewOptionKey>object_creation_style.parentheses</NewOptionKey>
        <Kind>Invert</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[var items = new List<string>() { "a", "b", "c" };]]></Before>
            <After><![CDATA[var items = new List<string> { "a", "b", "c" };]]></After>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="AddOrRemoveParenthesesFromConditionInConditionalOperator">
    <Id>RCS1051</Id>
    <Title>Add/remove parentheses from condition in conditional operator.</Title>
    <MessageFormat>{0} parentheses {1} condition.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[x = y != null ? "true" : "false"]]></Before>
        <After><![CDATA[x = (y != null) ? "true" : "false"]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="conditional_operator_condition_parentheses_style" IsRequired="true" />
    </ConfigOptions>
    <Options>
      <Option Identifier="RemoveParenthesesFromConditionOfConditionalExpressionWhenExpressionIsSingleToken">
        <Id>a</Id>
        <Title>Remove parentheses from condition of conditional expression (when condition is a single token).</Title>
        <MessageFormat>Remove parentheses from condition of conditional expression.</MessageFormat>
        <OptionKey>do_not_parenthesize_single_token</OptionKey>
        <NewOptionKey>conditional_expression_style.condition_parentheses</NewOptionKey>
        <Kind>Change</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[x = (condition) ? "true" : "false";]]></Before>
            <After><![CDATA[x = condition ? "true" : "false";]]></After>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="DeclareEachAttributeSeparately">
    <Id>RCS1052</Id>
    <Title>Declare each attribute separately.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[[Obsolete, Conditional("DEBUG")]
public void Foo()
{
}]]></Before>
        <After><![CDATA[[Obsolete]
[Conditional("DEBUG")]
public void Foo()
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="ReplaceForEachWithFor" IsObsolete="true">
    <Id>RCS1053</Id>
    <Title>Replace foreach statement with for statement.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
  </Analyzer>
  <Analyzer Identifier="MergeLocalDeclarationWithReturnStatement" IsObsolete="true">
    <Id>RCS1054</Id>
    <Title>Merge local declaration with return statement.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
  </Analyzer>
  <Analyzer Identifier="AvoidSemicolonAtEndOfDeclaration">
    <Id>RCS1055</Id>
    <Title>Avoid semicolon at the end of declaration.</Title>
    <MessageFormat>Remove semicolon from the end of declaration.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
};]]></Before>
        <After><![CDATA[public class Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AvoidUsageOfUsingAliasDirective">
    <Id>RCS1056</Id>
    <Title>Avoid usage of using alias directive.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[using S = System.String;

public class Foo
{
    public void Bar()
    {
        string s = S.Empty;
    }
}]]></Before>
        <After><![CDATA[public class Foo
{
    public void Bar()
    {
        string s = System.String.Empty;
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddEmptyLineBetweenDeclarations" IsObsolete="true">
    <Id>RCS1057</Id>
    <Title>Add empty line between declarations.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[class Foo
{
    void M1()
    {
    }
    void M2()
    {
    }
    /// <summary>
    /// ...
    /// </summary>
    void M3()
    {
    }
    string P1 { get; set; }
    [Obsolete]
    string P2 { get; set; }
}
enum Bar
{
    A = 0,
    /// <summary>
    /// ...
    /// </summary>
    B = 1,
    [Obsolete]
    C = 2,
}]]></Before>
        <After><![CDATA[class Foo
{
    void M1()
    {
    }

    void M2()
    {
    }

    /// <summary>
    /// ...
    /// </summary>
    void M3()
    {
    }

    string P1 { get; set; }

    [Obsolete]
    string P2 { get; set; }
}

enum Bar
{
    A = 0,

    /// <summary>
    /// ...
    /// </summary>
    B = 1,

    [Obsolete]
    C = 2,
}]]></After>
      </Sample>
    </Samples>
    <Remarks>This analyzer does not enforce an empty line between two single-line declaration.</Remarks>
  </Analyzer>
  <Analyzer Identifier="UseCompoundAssignment">
    <Id>RCS1058</Id>
    <Title>Use compound assignment.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <MinLanguageVersion>8.0 (??= operator)</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[x = x + 2;]]></Before>
        <After><![CDATA[x += 2;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[x ?? (x = M())]]></Before>
        <After><![CDATA[x ??= M()]]></After>
      </Sample>
    </Samples>
    <Links>
      <Link>
        <Url>https://docs.microsoft.com/cs-cz/dotnet/csharp/language-reference/operators/arithmetic-operators#compound-assignment</Url>
        <Text>Compound assignment</Text>
      </Link>
      <Link>
        <Url>https://docs.microsoft.com/dotnet/csharp/language-reference/operators/null-coalescing-operator</Url>
        <Text>?? and ??= operators</Text>
      </Link>
    </Links>
  </Analyzer>
  <Analyzer Identifier="AvoidLockingOnPubliclyAccessibleInstance">
    <Id>RCS1059</Id>
    <Title>Avoid locking on publicly accessible instance.</Title>
    <MessageFormat>Lock on private field instead of locking on '{0}'.</MessageFormat>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public void Foo()
{
    lock (this)
    {
    }
}]]></Before>
        <After><![CDATA[private readonly object _lockObject = new object();

public void Foo()
{
    lock (_lockObject)
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="DeclareEachTypeInSeparateFile">
    <Id>RCS1060</Id>
    <Title>Declare each type in separate file.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
}

public class Bar
{
}]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="MergeIfWithNestedIf">
    <Id>RCS1061</Id>
    <Title>Merge 'if' with nested 'if'.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
{
    if (condition2)
    {
    }
}]]></Before>
        <After><![CDATA[if (condition && condition2)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AvoidInterpolatedStringWithNoInterpolation" IsObsolete="true">
    <Id>RCS1062</Id>
    <Title>Avoid interpolated string with no interpolation.</Title>
    <MessageFormat>Remove '$' from interpolated string with no interpolation.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = $"";]]></Before>
        <After><![CDATA[string s = "";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AvoidUsageOfDoStatementToCreateInfiniteLoop">
    <Id>RCS1063</Id>
    <Title>([deprecated] use RCS1252 instead) Avoid usage of do statement to create an infinite loop.</Title>
    <MessageFormat>([deprecated] use RCS1252 instead) Use while statement to create an infinite loop.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[do
{
    // ...
}
while (true);]]></Before>
        <After><![CDATA[while (true)
{
    // ...
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AvoidUsageOfForStatementToCreateInfiniteLoop">
    <Id>RCS1064</Id>
    <Title>([deprecated] use RCS1252 instead) Avoid usage of for statement to create an infinite loop.</Title>
    <MessageFormat>([deprecated] use RCS1252 instead) Use while statement to create an infinite loop.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[for (;;)
{
}]]></Before>
        <After><![CDATA[while (true)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AvoidUsageOfWhileStatementToCreateInfiniteLoop">
    <Id>RCS1065</Id>
    <Title>([deprecated] use RCS1252 instead) Avoid usage of while statement to create an infinite loop.</Title>
    <MessageFormat>([deprecated] use RCS1252 instead) Use for statement to create an infinite loop.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[while (true)
{
}]]></Before>
        <After><![CDATA[for (;;)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveEmptyFinallyClause">
    <Id>RCS1066</Id>
    <Title>Remove empty 'finally' clause.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[try
{
    Foo();
}
finally
{
}]]></Before>
        <After><![CDATA[Foo();]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[try
{
    Foo();
}
catch (Exception ex)
{
}
finally
{
}]]></Before>
        <After><![CDATA[try
{
    Foo();
}
catch (Exception ex)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveArgumentListFromObjectCreation2" IsObsolete="true">
    <Id>RCS1067</Id>
    <Title>Remove argument list from object creation expression.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[var items = new List<string>() { "a", "b", "c" };]]></Before>
        <After><![CDATA[var items = new List<string> { "a", "b", "c" };]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="SimplifyLogicalNegation">
    <Id>RCS1068</Id>
    <Title>Simplify logical negation.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[bool f = !true;]]></Before>
        <After><![CDATA[bool f = false;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool f = !!f2;]]></Before>
        <After><![CDATA[bool f = f2;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool f = !items.Any(s => !string.IsNullOrEmpty(s));]]></Before>
        <After><![CDATA[bool f = items.All(s => string.IsNullOrEmpty(s));]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveUnnecessaryCaseLabel">
    <Id>RCS1069</Id>
    <Title>Remove unnecessary case label.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (s)
{
    case "a":
        return true;
    case "b":
    default:
        return false;
}]]></Before>
        <After><![CDATA[switch (s)
{
    case "a":
        return true;
    default:
        return false;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantDefaultSwitchSection">
    <Id>RCS1070</Id>
    <Title>Remove redundant default switch section.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (s)
{
    case "a":
        return true;
    case "b":
        return false;
    default:
        break;
}]]></Before>
        <After><![CDATA[switch (s)
{
    case "a":
        return true;
    case "b":
        return false;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantBaseConstructorCall">
    <Id>RCS1071</Id>
    <Title>Remove redundant base constructor call.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
    public Foo() : base()
    {
    }
}]]></Before>
        <After><![CDATA[public class Foo
{
    public Foo()
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveEmptyNamespaceDeclaration">
    <Id>RCS1072</Id>
    <Title>Remove empty namespace declaration.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[namespace Foo
{
}]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="ConvertIfToReturnStatement">
    <Id>RCS1073</Id>
    <Title>Convert 'if' to 'return' statement.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
{
    return true;
}
else
{
    return false;
}]]></Before>
        <After><![CDATA[return x;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (x != null)
{
    return x;
}
else
{
    return null;
}]]></Before>
        <After><![CDATA[return x;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantConstructor">
    <Id>RCS1074</Id>
    <Title>Remove redundant constructor.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
    public Foo()
    {
    }
}]]></Before>
        <After><![CDATA[public class Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AvoidEmptyCatchClauseThatCatchesSystemException">
    <Id>RCS1075</Id>
    <Title>Avoid empty catch clause that catches System.Exception.</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[try
{
    Foo();
}
catch (Exception ex)
{
}]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="FormatDeclarationBraces" IsObsolete="true">
    <Id>RCS1076</Id>
    <Title>Format declaration braces.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[interface IFoo
{ }]]></Before>
        <After><![CDATA[interface IFoo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="OptimizeLinqMethodCall">
    <Id>RCS1077</Id>
    <Title>Optimize LINQ method call.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[bool any = items.Where(predicate).Any();]]></Before>
        <After><![CDATA[bool any = items.Any(predicate);]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[int max = items.Select(selector).Max();]]></Before>
        <After><![CDATA[int max = items.Max(selector);]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[IEnumerable<Foo> x = items.Where(f => f is Foo).Cast<Foo>();]]></Before>
        <After><![CDATA[IEnumerable<Foo> x = items.OfType<Foo>();]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool x = items.Where((f) => Foo1(f)).Any(f => Foo2(f));]]></Before>
        <After><![CDATA[bool x = items.Any((f) => Foo1(f) && Foo2(f));]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[IEnumerable<object> x = items.Select(f => (object)f);]]></Before>
        <After><![CDATA[IEnumerable<object> x = items.Cast<object>();]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool x = items.FirstOrDefault((f) => Foo(f)) != null;]]></Before>
        <After><![CDATA[bool x = items.Any((f) => Foo(f));]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool x = items.FirstOrDefault() != null;]]></Before>
        <After><![CDATA[bool x = items.Any();]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (enumerable.Count() != 0)
{
}]]></Before>
        <After><![CDATA[if (enumerable.Any())
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (list.Count() == 1)
{
}]]></Before>
        <After><![CDATA[if (list.Count == 1)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[var stack = new Stack<object>();
// ...
object x = stack.First();]]></Before>
        <After><![CDATA[var stack = new Stack<object>();
// ...
object x = stack.Peek();]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[var queue = new Queue<object>();
// ...
object x = queue.First();]]></Before>
        <After><![CDATA[var queue = new Queue<object>();
// ...
object x = queue.Peek();]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[enumerable.Any() ? enumerable.First() : default]]></Before>
        <After><![CDATA[enumerable.FirstOrDefault()]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[enumerable.OrderBy(f => f).Reverse()]]></Before>
        <After><![CDATA[enumerable.OrderByDescending()]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[enumerable.SelectMany(f => f.Items).Count()]]></Before>
        <After><![CDATA[enumerable.Sum(f => f.Items.Count)]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[listOfT.Select(f => M(f)).ToList()]]></Before>
        <After><![CDATA[listOfT.ConvertAll(f => M(f))]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseEmptyStringLiteralOrStringEmpty">
    <Id>RCS1078</Id>
    <Title>Use "" or 'string.Empty'.</Title>
    <MessageFormat>Use {0}</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = string.Empty;]]></Before>
        <After><![CDATA[string s = "";]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="empty_string_style" IsRequired="true" />
    </ConfigOptions>
    <Options>
      <Option Identifier="UseStringEmptyInsteadOfEmptyStringLiteral">
        <Title>Use string.Empty instead of "".</Title>
        <Id>i</Id>
        <OptionKey>invert</OptionKey>
        <NewOptionKey>empty_string_style</NewOptionKey>
        <Kind>Invert</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[string s = "";]]></Before>
            <After><![CDATA[string s = string.Empty;]]></After>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="ThrowingOfNewNotImplementedException">
    <Id>RCS1079</Id>
    <Title>Throwing of new NotImplementedException.</Title>
    <MessageFormat>Implement the functionality instead of throwing new NotImplementedException.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public void Foo()
{
    throw new NotImplementedException();
}]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseCountOrLengthPropertyInsteadOfAnyMethod">
    <Id>RCS1080</Id>
    <Title>Use 'Count/Length' property instead of 'Any' method.</Title>
    <MessageFormat>Use '{0}' property instead of 'Any' method.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (list.Any())
{
}]]></Before>
        <After><![CDATA[if (list.Count > 0)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="SplitVariableDeclaration">
    <Id>RCS1081</Id>
    <Title>Split variable declaration.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[private string s, s2;]]></Before>
        <After><![CDATA[private string s;
private string s2;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseCountOrLengthPropertyInsteadOfCountMethod" IsObsolete="true">
    <Id>RCS1082</Id>
    <Title>Use 'Count/Length' property instead of 'Count' method.</Title>
    <MessageFormat>Use '{0}' property instead of 'Count' method.</MessageFormat>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (list.Count() == 1)
{
}]]></Before>
        <After><![CDATA[if (list.Count == 1)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="CallAnyInsteadOfCount" IsObsolete="true">
    <Id>RCS1083</Id>
    <Title>Call 'Enumerable.Any' instead of 'Enumerable.Count'.</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (enumerable.Count() == 0)
{
}]]></Before>
        <After><![CDATA[if (!enumerable.Any())
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseCoalesceExpressionInsteadOfConditionalExpression">
    <Id>RCS1084</Id>
    <Title>Use coalesce expression instead of conditional expression.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string x = (s != null) ? s : "";]]></Before>
        <After><![CDATA[string x = s ?? "";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseAutoProperty">
    <Id>RCS1085</Id>
    <Title>Use auto-implemented property.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[private string _foo;

public string Foo
{
    get { return _foo; }
    set { _foo = value; }
}]]></Before>
        <After><![CDATA[public string Foo { get; set; }]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseLinefeedAsNewLine" IsObsolete="true">
    <Id>RCS1086</Id>
    <Title>Use linefeed as new line.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
  </Analyzer>
  <Analyzer Identifier="UseCarriageReturnAndLinefeedAsNewLine" IsObsolete="true">
    <Id>RCS1087</Id>
    <Title>Use carriage return + linefeed as new line.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
  </Analyzer>
  <Analyzer Identifier="UseSpacesInsteadOfTab" IsObsolete="true">
    <Id>RCS1088</Id>
    <Title>Use space(s) instead of tab.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
  </Analyzer>
  <Analyzer Identifier="UseUnaryOperatorInsteadOfAssignment">
    <Id>RCS1089</Id>
    <Title>Use --/++ operator instead of assignment.</Title>
    <MessageFormat>Use {0} operator instead of assignment.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[i = i + 1;]]></Before>
        <After><![CDATA[i++;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[M(i + 1);]]></Before>
        <After><![CDATA[M(++i);]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="ConfigureAwait">
    <Id>RCS1090</Id>
    <Title>Add/remove 'ConfigureAwait(false)' call.</Title>
    <MessageFormat>{0} 'ConfigureAwait(false)' call.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public async Task FooAsync()
{
    await GetValueAsync();
}]]></Before>
        <After><![CDATA[public async Task FooAsync()
{
    await GetValueAsync().ConfigureAwait(false);
}]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="configure_await" IsRequired="true" />
    </ConfigOptions>
    <Options>
      <Option Identifier="RemoveCallToConfigureAwait">
        <Title>Remove call to 'ConfigureAwait'.</Title>
        <Id>i</Id>
        <OptionKey>invert</OptionKey>
        <NewOptionKey>configure_await</NewOptionKey>
        <Kind>Invert</Kind>
        <SupportsFadeOut>true</SupportsFadeOut>
        <Samples>
          <Sample>
            <Before><![CDATA[public async Task FooAsync()
{
    await GetValueAsync().ConfigureAwait(false);
}]]></Before>
            <After><![CDATA[public async Task FooAsync()
{
    await GetValueAsync();
}]]></After>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="RemoveEmptyRegion">
    <Id>RCS1091</Id>
    <Title>Remove empty region.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[#region Region
            
#endregion]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddEmptyLineBeforeWhileInDoStatement" IsObsolete="true">
    <Id>RCS1092</Id>
    <Title>Add empty line before 'while' keyword in 'do' statement.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[do
{
    Foo();
} while (x);]]></Before>
        <After><![CDATA[do
{
    Foo();

} while (x);]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveFileWithNoCode">
    <Id>RCS1093</Id>
    <Title>Remove file with no code.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer Identifier="DeclareUsingDirectiveOnTopLevel">
    <Id>RCS1094</Id>
    <Title>Declare using directive on top level.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[namespace Foo
{
    using System;
}]]></Before>
        <After><![CDATA[using System;

namespace Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseCSharp6DictionaryInitializer" IsObsolete="true">
    <Id>RCS1095</Id>
    <Title>Use C# 6.0 dictionary initializer.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer Identifier="UseHasFlagMethodOrBitwiseOperator">
    <Id>RCS1096</Id>
    <Title>Use 'HasFlag' method or bitwise operator.</Title>
    <MessageFormat>Use {0}.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[options.HasFlag(RegexOptions.IgnoreCase)]]></Before>
        <After><![CDATA[(options & RegexOptions.IgnoreCase) != 0]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="enum_has_flag_style" IsRequired="true" />
    </ConfigOptions>
    <Options>
      <Option Identifier="ConvertBitwiseOperationToHasFlagCall">
        <Title>Convert bitwise operation to 'HasFlag' call.</Title>
        <Id>i</Id>
        <OptionKey>invert</OptionKey>
        <NewOptionKey>enum_flag_operation_style</NewOptionKey>
        <Kind>Invert</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[(options & RegexOptions.IgnoreCase) != 0]]></Before>
            <After><![CDATA[options.HasFlag(RegexOptions.IgnoreCase)]]></After>
          </Sample>
        </Samples>
        <Links>
          <Link>
            <Url>https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/</Url>
            <Text>Performance Improvements in .NET Core 2.1</Text>
          </Link>
        </Links>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantToStringCall">
    <Id>RCS1097</Id>
    <Title>Remove redundant 'ToString' call.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[string x = s.ToString();]]></Before>
        <After><![CDATA[string x = s;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[string x = $"{s.ToString()}";]]></Before>
        <After><![CDATA[string x = $"{s}";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="ConstantValuesShouldBePlacedOnRightSideOfComparisons">
    <Id>RCS1098</Id>
    <Title>Constant values should be placed on right side of comparisons.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (null == x)
{ 
}]]></Before>
        <After><![CDATA[if (x == null)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="DefaultLabelShouldBeLastLabelInSwitchSection">
    <Id>RCS1099</Id>
    <Title>Default label should be the last label in a switch section.</Title>
    <MessageFormat>Move default label to the last position in a switch section.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (s)
{
    default:
    case "a":
    case "b":
        break;
}]]></Before>
        <After><![CDATA[switch (s)
{
    case "b":
    case "a":
    default:
        break;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="FormatDocumentationSummaryOnSingleLine">
    <Id>RCS1100</Id>
    <Title>([deprecated] use RCS1253 instead) Format documentation summary on a single line.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// ...
/// </summary>
public void Foo()
{
}]]></Before>
        <After><![CDATA[/// <summary>...</summary>
public void Foo()
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="FormatDocumentationSummaryOnMultipleLines">
    <Id>RCS1101</Id>
    <Title>([deprecated] use RCS1253 instead) Format documentation summary on multiple lines.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>...</summary>
public void Foo()
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// ...
/// </summary>
public void Foo()
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="MakeClassStatic">
    <Id>RCS1102</Id>
    <Title>Make class static.</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
    private static string _f;

    public static void Bar()
    {
    }
}]]></Before>
        <After><![CDATA[public static class Foo
{
    private static string _f;

    public static void Bar()
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="ConvertIfToAssignment">
    <Id>RCS1103</Id>
    <Title>Convert 'if' to assignment.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
{
    f = true;
}
else
{
    f = false;
}]]></Before>
        <After><![CDATA[f = condition;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (x != null)
{
    y = x;
}
else
{
    y = null;
}]]></Before>
        <After><![CDATA[y = x;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="SimplifyConditionalExpression">
    <Id>RCS1104</Id>
    <Title>Simplify conditional expression.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[bool x = y ? true : false;]]></Before>
        <After><![CDATA[bool x = y;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool x = y ? false : true;]]></Before>
        <After><![CDATA[bool x = !y;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool x = y ? z : false;]]></Before>
        <After><![CDATA[bool x = y && z;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool x = y ? true : z;]]></Before>
        <After><![CDATA[bool x = y || z;]]></After>
      </Sample>
    </Samples>
    <Options>
      <Option Identifier="DoNotSimplifyConditionalExpressionWhenConditionIsInverted" IsObsolete="true">
        <Title>Do not simplify conditional expression when condition is inverted.</Title>
        <Id>a</Id>
        <OptionKey>suppress_when_condition_is_inverted</OptionKey>
        <Kind>Disable</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[bool x = y ? false : z;]]></Before>
          </Sample>
          <Sample>
            <Before><![CDATA[bool x = y ? z : true;]]></Before>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="UnnecessaryInterpolation">
    <Id>RCS1105</Id>
    <Title>Unnecessary interpolation.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = $"a{"b"}c";]]></Before>
        <After><![CDATA[string s = $"abc";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveEmptyDestructor">
    <Id>RCS1106</Id>
    <Title>Remove empty destructor.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
    ~Foo()
    {
    }
}]]></Before>
        <After><![CDATA[public class Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantStringToCharArrayCall">
    <Id>RCS1107</Id>
    <Title>Remove redundant 'ToCharArray' call.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[foreach (char ch in s.ToCharArray())
{
}]]></Before>
        <After><![CDATA[foreach (char ch in s)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddStaticModifierToAllPartialClassDeclarations">
    <Id>RCS1108</Id>
    <Title>Add 'static' modifier to all partial class declarations.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public static partial class Foo
{
}

public partial class Foo
{
}]]></Before>
        <After><![CDATA[public static partial class Foo
{
}

public static partial class Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="CallCastInsteadOfSelect" IsObsolete="true">
    <Id>RCS1109</Id>
    <Title>Call 'Enumerable.Cast' instead of 'Enumerable.Select'.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[IEnumerable<object> x = items.Select(f => (object)f);]]></Before>
        <After><![CDATA[IEnumerable<object> x = items.Cast<object>();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="DeclareTypeInsideNamespace">
    <Id>RCS1110</Id>
    <Title>Declare type inside namespace.</Title>
    <MessageFormat>Declare '{0}' inside namespace.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
}]]></Before>
        <After><![CDATA[namespace Namespace
{
    public class Foo
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddBracesToSwitchSectionWithMultipleStatements">
    <Id>RCS1111</Id>
    <Title>Add braces to switch section with multiple statements.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (s)
{
    case "a":
        Foo();
        break;
}]]></Before>
        <After><![CDATA[switch (s)
{
    case "a":
        {
            Foo();
            break;
        }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="CombineEnumerableWhereMethodChain">
    <Id>RCS1112</Id>
    <Title>Combine 'Enumerable.Where' method chain.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[IEnumerable<string> x = items.Where(f => Foo(f)).Where(f => Bar(f));]]></Before>
        <After><![CDATA[IEnumerable<string> x = items.Where(f => Foo(f) && Bar(f));]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseStringIsNullOrEmptyMethod">
    <Id>RCS1113</Id>
    <Title>Use 'string.IsNullOrEmpty' method.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (s == null || s.Length == 0)
{
}]]></Before>
        <After><![CDATA[if (string.IsNullOrEmpty(s))
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantDelegateCreation">
    <Id>RCS1114</Id>
    <Title>Remove redundant delegate creation.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[Changed += new EventHandler(OnChanged);]]></Before>
        <After><![CDATA[Changed += OnChanged;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="ReplaceReturnStatementWithExpressionStatement" IsObsolete="true">
    <Id>RCS1115</Id>
    <Title>Replace yield/return statement with expression statement.</Title>
    <MessageFormat>Replace {0} statement with expression statement.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
  </Analyzer>
  <Analyzer Identifier="AddBreakStatementToSwitchSection" IsObsolete="true">
    <Id>RCS1116</Id>
    <Title>Add break statement to switch section.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer Identifier="AddReturnStatementThatReturnsDefaultValue" IsObsolete="true">
    <Id>RCS1117</Id>
    <Title>Add return statement that returns default value.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer Identifier="MarkLocalVariableAsConst">
    <Id>RCS1118</Id>
    <Title>Mark local variable as const.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = "a";
string s2 = s + "b";]]></Before>
        <After><![CDATA[const string s = "a";
string s2 = s + "b";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="CallFindInsteadOfFirstOrDefault" IsObsolete="true">
    <Id>RCS1119</Id>
    <Title>Call 'Find' instead of 'FirstOrDefault'.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = list.FirstOrDefault(f => f.StartsWith("a"));]]></Before>
        <After><![CDATA[string s = list.Find(f => f.StartsWith("a"));]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseElementAccessInsteadOfElementAt" IsObsolete="true">
    <Id>RCS1120</Id>
    <Title>Use [] instead of calling 'ElementAt'.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = list.ElementAt(1);]]></Before>
        <After><![CDATA[var x = list[1];]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseElementAccessInsteadOfFirst" IsObsolete="true">
    <Id>RCS1121</Id>
    <Title>Use [] instead of calling 'First'.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = list.First();]]></Before>
        <After><![CDATA[var x = list[0];]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddMissingSemicolon" IsObsolete="true">
    <Id>RCS1122</Id>
    <Title>Add missing semicolon.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
  </Analyzer>
  <Analyzer Identifier="AddParenthesesWhenNecessary">
    <Id>RCS1123</Id>
    <Title>Add parentheses when necessary.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x || y && z)
{
}]]></Before>
        <After><![CDATA[if (x || (y && z))
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[x?.y!.z]]></Before>
        <After><![CDATA[(x?.y)!.z]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="InlineLocalVariable">
    <Id>RCS1124</Id>
    <Title>Inline local variable.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[IEnumerable<object> items = GetValues();
foreach (object item in items)
{
}]]></Before>
        <After><![CDATA[foreach (object item in GetValues())
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="MarkMemberAsStatic" IsObsolete="true">
    <Id>RCS1125</Id>
    <Title>Mark member as static.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer Identifier="AddBracesToIfElse">
    <Id>RCS1126</Id>
    <Title>Add braces to if-else.</Title>
    <MessageFormat>Add braces to {0}.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
    Foo();
else
    Bar();]]></Before>
        <After><![CDATA[if (condition)
{
    Foo();
}
else
{
    Bar();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="MergeLocalDeclarationWithAssignment" IsObsolete="true">
    <Id>RCS1127</Id>
    <Title>Merge local declaration with assignment.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[string s;
s = "";]]></Before>
        <After><![CDATA[string s = "";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseCoalesceExpression">
    <Id>RCS1128</Id>
    <Title>Use coalesce expression.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = GetValue();

if (s == null)
{
    s = "";
}]]></Before>
        <After><![CDATA[string s = GetValue() ?? "";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantFieldInitialization">
    <Id>RCS1129</Id>
    <Title>Remove redundant field initialization.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[private bool _f = false;]]></Before>
        <After><![CDATA[private bool _f;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="BitwiseOperationOnEnumWithoutFlagsAttribute">
    <Id>RCS1130</Id>
    <Title>Bitwise operation on enum without Flags attribute.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[DayOfWeek x = dayOfWeek | DayOfWeek.Tuesday;]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="ReplaceReturnWithYieldReturn" IsObsolete="true">
    <Id>RCS1131</Id>
    <Title>Replace return with yield return.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantOverridingMember">
    <Id>RCS1132</Id>
    <Title>Remove redundant overriding member.</Title>
    <MessageFormat>Remove redundant overriding {0}.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
    public override string ToString()
    {
        return base.ToString();
    }
}]]></Before>
        <After><![CDATA[public class Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantDisposeOrCloseCall">
    <Id>RCS1133</Id>
    <Title>Remove redundant Dispose/Close call.</Title>
    <MessageFormat>Remove redundant '{0}' call.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[using (streamReader)
{
    // ...

    streamReader.Dispose();
}]]></Before>
        <After><![CDATA[using (streamReader)
{
    // ...
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantStatement">
    <Id>RCS1134</Id>
    <Title>Remove redundant statement.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
{
    // ...

    return false;
}

return false;]]></Before>
        <After><![CDATA[if (x)
{
    // ...
}

return false;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[public void Foo()
{
    // ...

    return;
}]]></Before>
        <After><![CDATA[public void Foo()
{
    // ...
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[foreach (object item in items)
{
    /// ...

    continue;
}]]></Before>
        <After><![CDATA[]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="DeclareEnumMemberWithZeroValue">
    <Id>RCS1135</Id>
    <Title>Declare enum member with zero value (when enum has FlagsAttribute).</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[[Flags]
public enum Foo
{
    A = 1,
    B = 2
}]]></Before>
        <After><![CDATA[[Flags]
public enum Foo
{
    None = 0,
    A = 1,
    B = 2
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="MergeSwitchSectionsWithEquivalentContent">
    <Id>RCS1136</Id>
    <Title>Merge switch sections with equivalent content.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[switch (s)
{
    case "a":
        break;
    case "b":
        break;
}]]></Before>
        <After><![CDATA[switch (s)
{
    case "a":
    case "b":
        break;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddDocumentationComment" IsObsolete="true">
    <Id>RCS1137</Id>
    <Title>Add documentation comment to publicly visible type or member.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer Identifier="AddSummaryToDocumentationComment">
    <Id>RCS1138</Id>
    <Title>Add summary to documentation comment.</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// 
/// </summary>
public void Foo()
{
}]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddSummaryElementToDocumentationComment">
    <Id>RCS1139</Id>
    <Title>Add summary element to documentation comment.</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <param name="parameter"></param>
public void Foo(object parameter)
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// 
/// </summary>
/// <param name="parameter"></param>
public void Foo(object parameter)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddExceptionToDocumentationComment">
    <Id>RCS1140</Id>
    <Title>Add exception to documentation comment.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// ...
/// </summary>
/// <param name="parameter"></param>
public void Foo(object parameter)
{
    if (parameter == null)
        throw new ArgumentNullException(nameof(parameter));
}]]></Before>
        <After><![CDATA[/// <summary>
/// ...
/// </summary>
/// <param name="parameter"></param>
/// <exception cref="ArgumentNullException"><paramref name="parameter"/> is <c>null</c>.</exception>
public void Foo(object parameter)
{
    if (parameter == null)
        throw new ArgumentNullException(nameof(parameter));
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddParamElementToDocumentationComment">
    <Id>RCS1141</Id>
    <Title>Add 'param' element to documentation comment.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// ...
/// </summary>
public void Foo(object parameter)
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// ...
/// </summary>
/// <param name="parameter"></param>
public void Foo(object parameter)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddTypeParamElementToDocumentationComment">
    <Id>RCS1142</Id>
    <Title>Add 'typeparam' element to documentation comment.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// ...
/// </summary>
/// <typeparam name="T1"></typeparam>
public class Foo<T1, T2>
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// ...
/// </summary>
/// <typeparam name="T1"></typeparam>
/// <typeparam name="T2"></typeparam>
public class Foo<T1, T2>
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="SimplifyCoalesceExpression">
    <Id>RCS1143</Id>
    <Title>Simplify coalesce expression.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = default(string) ?? "";]]></Before>
        <After><![CDATA[string s = "";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="MarkContainingClassAsAbstract" IsObsolete="true">
    <Id>RCS1144</Id>
    <Title>Mark containing class as abstract.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantAsOperator">
    <Id>RCS1145</Id>
    <Title>Remove redundant 'as' operator.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = null;

string s2 = s as string;]]></Before>
        <After><![CDATA[string s2 = s;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseConditionalAccess">
    <Id>RCS1146</Id>
    <Title>Use conditional access.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <MinLanguageVersion>6.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[if (s != null && s.StartsWith("a"))
{
}]]></Before>
        <After><![CDATA[if (s?.StartsWith("a") == true)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (dic != null && dic[0].StartsWith("a"))
{
}]]></Before>
        <After><![CDATA[if (dic?[0].StartsWith("a") == true)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (x != null)
    x.Foo();]]></Before>
        <After><![CDATA[x?.Foo();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveInapplicableModifier" IsObsolete="true">
    <Id>RCS1147</Id>
    <Title>Remove inapplicable modifier.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
  </Analyzer>
  <Analyzer Identifier="RemoveUnreachableCode" IsObsolete="true">
    <Id>RCS1148</Id>
    <Title>Remove unreachable code.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
  </Analyzer>
  <Analyzer Identifier="RemoveImplementationFromAbstractMember" IsObsolete="true">
    <Id>RCS1149</Id>
    <Title>Remove implementation from abstract member.</Title>
    <MessageFormat>Remove implementation from {0}.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
  </Analyzer>
  <Analyzer Identifier="CallStringConcatInsteadOfStringJoin" IsObsolete="true">
    <Id>RCS1150</Id>
    <Title>Call string.Concat instead of string.Join.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = string.Join("", "a", "b", "c");]]></Before>
        <After><![CDATA[string s = string.Concat("a", "b", "c");]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantCast">
    <Id>RCS1151</Id>
    <Title>Remove redundant cast.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[var b = new Base();

((Foo)b).Bar();]]></Before>
        <After><![CDATA[b.Bar();]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[IEnumerable<string> x = EnumerateStrings().Cast<string>();]]></Before>
        <After><![CDATA[IEnumerable<string> x = EnumerateStrings();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="MemberTypeMustMatchOverriddenMemberType" IsObsolete="true">
    <Id>RCS1152</Id>
    <Title>Member type must match overridden member type.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer Identifier="AddEmptyLineAfterClosingBrace" IsObsolete="true">
    <Id>RCS1153</Id>
    <Title>Add empty line after closing brace.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
{
}
Foo();]]></Before>
        <After><![CDATA[if (x)
{
}

Foo();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="SortEnumMembers">
    <Id>RCS1154</Id>
    <Title>Sort enum members.</Title>
    <MessageFormat>Sort '{0}' members.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public enum Foo
{
    D = 4,
    B = 2,
    A = 1,
    C = 3
}]]></Before>
        <After><![CDATA[public enum Foo
{
    A = 1,
    B = 2,
    C = 3,
    D = 4
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseStringComparison">
    <Id>RCS1155</Id>
    <Title>Use StringComparison when comparing strings.</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x.ToLower() == y.ToLower())
{
}]]></Before>
        <After><![CDATA[if (string.Equals(x, y, StringComparison.OrdinalIgnoreCase))
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseStringLengthInsteadOfComparisonWithEmptyString">
    <Id>RCS1156</Id>
    <Title>Use string.Length instead of comparison with empty string.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (s == "")
{
}]]></Before>
        <After><![CDATA[if (s?.Length == 0)
{
}]]></After>
      </Sample>
    </Samples>
    <Links>
      <Link>
        <Url>https://docs.microsoft.com/en-us/visualstudio/code-quality/ca1820</Url>
        <Text>CA1820: Test for empty strings using string length</Text>
      </Link>
    </Links>
  </Analyzer>
  <Analyzer Identifier="CompositeEnumValueContainsUndefinedFlag">
    <Id>RCS1157</Id>
    <Title>Composite enum value contains undefined flag.</Title>
    <MessageFormat>Composite enum value contains undefined flag {0}.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[[Flags]
public enum Foo
{
    None = 0,
    A = 1,
    B = 2,
    C = 4,
    D = 8,
    X = 17
}]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="StaticMemberInGenericTypeShouldUseTypeParameter">
    <Id>RCS1158</Id>
    <Title>Static member in generic type should use a type parameter.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo<T>
{
    public static void Bar()
    {
    }
}]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseGenericEventHandler">
    <Id>RCS1159</Id>
    <Title>Use EventHandler&lt;T&gt;.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
    public event FooEventHandler EventName;
}

public delegate void FooEventHandler(object sender, FooEventArgs args);]]></Before>
        <After><![CDATA[public class Foo
{
    public event EventHandler<FooEventArgs> EventName;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AbstractTypeShouldNotHavePublicConstructors">
    <Id>RCS1160</Id>
    <Title>Abstract type should not have public constructors.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public abstract class Foo
{
    public Foo()
    {
    }
}]]></Before>
        <After><![CDATA[public abstract class Foo
{
    protected Foo()
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="EnumShouldDeclareExplicitValues">
    <Id>RCS1161</Id>
    <Title>Enum should declare explicit values.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public enum Foo
{
    A,
    B,
    C,
}]]></Before>
        <After><![CDATA[public enum Foo
{
    A = 0,
    B = 1,
    C = 2,
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AvoidChainOfAssignments">
    <Id>RCS1162</Id>
    <Title>Avoid chain of assignments.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[x = y = z;]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UnusedParameter">
    <Id>RCS1163</Id>
    <Title>Unused parameter.</Title>
    <MessageFormat>Unused parameter '{0}'.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public bool Bar(object parameter)
{
    return false;
}]]></Before>
      </Sample>
    </Samples>
    <Remarks>This analyzer does not provide a code fix. Use built-in "Change signature.." dialog to remove a parameter.

Unused parameter is not reported when its name consists of underscore(s).</Remarks>
  </Analyzer>
  <Analyzer Identifier="UnusedTypeParameter">
    <Id>RCS1164</Id>
    <Title>Unused type parameter.</Title>
    <MessageFormat>Unused type parameter '{0}'.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public bool Bar<T>()
{
    return false
}]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UnconstrainedTypeParameterCheckedForNull">
    <Id>RCS1165</Id>
    <Title>Unconstrained type parameter checked for null.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public void Foo<T1>() where T1 : new()
{
    var x = default(T1);

    if (x == null)
    {
    }
}]]></Before>
        <After><![CDATA[if (EqualityComparer<T1>.Default.Equals(x, default(T1)))
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="ValueTypeObjectIsNeverEqualToNull">
    <Id>RCS1166</Id>
    <Title>Value type object is never equal to null.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[int x = 0;
IntPtr y = IntPtr.Zero

// ...

if (x == null)
{
}

if (y == null)
{
}]]></Before>
        <After><![CDATA[if (x == 0)
{
}

if (y == default)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="OverridingMemberCannotChangeAccessModifiers" IsObsolete="true">
    <Id>RCS1167</Id>
    <Title>Overriding member cannot change access modifiers.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
  </Analyzer>
  <Analyzer Identifier="ParameterNameDiffersFromBase">
    <Id>RCS1168</Id>
    <Title>Parameter name differs from base name.</Title>
    <MessageFormat>Parameter name '{0}' differs from base name '{1}'.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[interface IFoo
{
    string Bar(object parameter);
}

abstract class Foo : IFoo
{
    public abstract string Bar(object value);
}]]></Before>
        <After><![CDATA[interface IFoo
{
    string Bar(object parameter);
}

abstract class Foo : IFoo
{
    public abstract string Bar(object parameter)
};]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="MakeFieldReadOnly">
    <Id>RCS1169</Id>
    <Title>Make field read-only.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
    private int _f;

    public Foo()
    {
        _f = 0;
    }
}]]></Before>
        <After><![CDATA[private readonly int _f;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseReadOnlyAutoProperty">
    <Id>RCS1170</Id>
    <Title>Use read-only auto-implemented property.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <MinLanguageVersion>6.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[public object Foo { get; private set; }]]></Before>
        <After><![CDATA[public object Foo { get; }]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="SimplifyLazyInitialization">
    <Id>RCS1171</Id>
    <Title>Simplify lazy initialization.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public object Foo()
{
    if (_foo == null)
    {
        _foo = Initialize();
    }

    return _foo;
}]]></Before>
        <After><![CDATA[public object Foo()
{
    return _foo ?? (_foo = Initialize());
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseIsOperatorInsteadOfAsOperator">
    <Id>RCS1172</Id>
    <Title>Use 'is' operator instead of 'as' operator.</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x as string != null)
{
}]]></Before>
        <After><![CDATA[if (x is string)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseCoalesceExpressionInsteadOfIf">
    <Id>RCS1173</Id>
    <Title>Use coalesce expression instead of 'if'.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x != null)
{
    z = x;
}
else
{
    z = y;
}]]></Before>
        <After><![CDATA[z = x ?? y;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantAsyncAwait">
    <Id>RCS1174</Id>
    <Title>Remove redundant async/await.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[public static async Task<object> FooAsync()
{
    return await GetAsync().ConfigureAwait(false);
}]]></Before>
        <After><![CDATA[public static Task<object> FooAsync()
{
    return GetAsync();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UnusedThisParameter">
    <Id>RCS1175</Id>
    <Title>Unused 'this' parameter.</Title>
    <MessageFormat>Unused 'this' parameter '{0}'.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public static bool Bar(this Foo foo, object parameter)
{
    return parameter != null;
}]]></Before>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseVarInsteadOfExplicitTypeWhenTypeIsNotObvious">
    <Id>RCS1176</Id>
    <Title>Use 'var' instead of explicit type (when the type is not obvious).</Title>
    <MessageFormat>Use 'var' instead of explicit type.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = GetValue();]]></Before>
        <After><![CDATA[var s = GetValue();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseVarInsteadOfExplicitTypeInForEach">
    <Id>RCS1177</Id>
    <Title>Use 'var' instead of explicit type (in foreach).</Title>
    <MessageFormat>Use 'var' instead of explicit type.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[foreach (string item in items)
{
}]]></Before>
        <After><![CDATA[foreach (var item in items)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="CallDebugFailInsteadOfDebugAssert" IsObsolete="true">
    <Id>RCS1178</Id>
    <Title>Call Debug.Fail instead of Debug.Assert.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[Debug.Assert(false, "message");]]></Before>
        <After><![CDATA[Debug.Fail("message");]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UnnecessaryAssignment">
    <Id>RCS1179</Id>
    <Title>Unnecessary assignment.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
{
    x = 1;
}
else
{
    x = 2;
}

return x;]]></Before>
        <After><![CDATA[if (condition)
{
    return 1;
}
else
{
    return 2;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="InlineLazyInitialization">
    <Id>RCS1180</Id>
    <Title>Inline lazy initialization.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[List<object> items = null;

// ...

if (items == null)
{
    items = new List<object>();
}

items.Add(x);]]></Before>
        <After><![CDATA[(items ?? (items = new List<object>())).Add(x);]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="ConvertCommentToDocumentationComment">
    <Id>RCS1181</Id>
    <Title>Convert comment to documentation comment.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[// Represents foo.
public class Foo
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// Represents foo.
/// </summary>
public class Foo
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[public string Value { get; } // Gets a value.]]></Before>
        <After><![CDATA[/// <summary>
/// Gets a value.
/// </summary>
public string Value { get; }]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantBaseInterface">
    <Id>RCS1182</Id>
    <Title>Remove redundant base interface.</Title>
    <MessageFormat>Interface '{0}' is already implemented by '{1}'.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo<T> : List<T>, IEnumerable<T>
{
}]]></Before>
        <After><![CDATA[public class Foo<T> : List<T>
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="FormatInitializerWithSingleExpressionOnSingleLine" IsObsolete="true">
    <Id>RCS1183</Id>
    <Title>Format initializer with single expression on single line.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var dic = new Dictionary<int, string>()
{
    { 0, "0" }
};]]></Before>
        <After><![CDATA[var dic = new Dictionary<int, string>() { { 0, "0" } };]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="FormatConditionalExpression" IsObsolete="true">
    <Id>RCS1184</Id>
    <Title>Format conditional expression (format ? and : on next line).</Title>
    <MessageFormat>Format conditional expression.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var y = (x) ?
Foo() :
Bar();]]></Before>
        <After><![CDATA[var y = (x)
? Foo()
: Bar();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="FormatSingleLineBlock" IsObsolete="true">
    <Id>RCS1185</Id>
    <Title>Format single-line block.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[void Foo() { Bar(); }]]></Before>
        <After><![CDATA[void Foo()
{
    Bar();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseRegexInstanceInsteadOfStaticMethod">
    <Id>RCS1186</Id>
    <Title>Use Regex instance instead of static method.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[private void Bar()
{
    bool isMatch = Regex.IsMatch("abc", @"\w");
}]]></Before>
        <After><![CDATA[private readonly Regex _regex = new Regex(@"\w");

private void Bar()
{
    bool isMatch = _regex.IsMatch("abc");
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseConstantInsteadOfField">
    <Id>RCS1187</Id>
    <Title>Use constant instead of field.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[private static readonly int _foo = 0;]]></Before>
        <After><![CDATA[private const int _foo = 0;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantAutoPropertyInitialization">
    <Id>RCS1188</Id>
    <Title>Remove redundant auto-property initialization.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public string Foo { get; set; } = null;]]></Before>
        <After><![CDATA[public string Foo { get; set; }]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddOrRemoveRegionName">
    <Id>RCS1189</Id>
    <Title>Add or remove region name.</Title>
    <MessageFormat>{0} region name {1} #endregion.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[#region Methods
public static void Foo()
{
}
#endregion]]></Before>
        <After><![CDATA[#region Methods
public static void Foo()
{
}
#endregion Methods]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="JoinStringExpressions">
    <Id>RCS1190</Id>
    <Title>Join string expressions.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = "a" + "b";]]></Before>
        <After><![CDATA[string s = "ab";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="DeclareEnumValueAsCombinationOfNames">
    <Id>RCS1191</Id>
    <Title>Declare enum value as combination of names.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[[Flags]
public enum Foo
{
    None = 0,
    A = 1,
    B = 2,
    C = 4,
    ABC = 7
}]]></Before>
        <After><![CDATA[[Flags]
public enum Foo
{
    None = 0,
    A = 1,
    B = 2,
    C = 4,
    ABC = A | B | C
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UnnecessaryUsageOfVerbatimStringLiteral">
    <Id>RCS1192</Id>
    <Title>Unnecessary usage of verbatim string literal.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = @"textWithoutEscapeSequence";]]></Before>
        <After><![CDATA[string s = "textWithoutEscapeSequence";]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="OverridingMemberShouldNotChangeParamsModifier">
    <Id>RCS1193</Id>
    <Title>Overriding member should not change 'params' modifier.</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Base
{
    public virtual void Foo(params object[] values)
    {
    }
}

public class Derived : Base
{
    public override void Foo(object[] values)
    {
    }
}]]></Before>
        <After><![CDATA[public class Derived : Base
{
    public override void Foo(params object[] values)
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="ImplementExceptionConstructors">
    <Id>RCS1194</Id>
    <Title>Implement exception constructors.</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class FooException : Exception
{
}]]></Before>
        <After><![CDATA[public class FooException : Exception
{
    public FooException() : base()
    {
    }

    public FooException(string message) : base(message)
    {
    }

    public FooException(string message, Exception innerException) : base(message, innerException)
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseExclusiveOrOperator">
    <Id>RCS1195</Id>
    <Title>Use ^ operator.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if ((x && !y) || (!x && y))
{
}]]></Before>
        <After><![CDATA[if (x ^ y)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="CallExtensionMethodAsInstanceMethod">
    <Id>RCS1196</Id>
    <Title>Call extension method as instance method.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = Enumerable.Select(items, f => f.ToString())]]></Before>
        <After><![CDATA[var x = items.Select(f => f.ToString());]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="OptimizeStringBuilderAppendCall">
    <Id>RCS1197</Id>
    <Title>Optimize StringBuilder.Append/AppendLine call.</Title>
    <MessageFormat>Optimize StringBuilder.{0} call.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[sb.Append(s + "x");]]></Before>
        <After><![CDATA[sb.Append(s).Append("x");]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AvoidBoxingOfValueType">
    <Id>RCS1198</Id>
    <Title>Avoid unnecessary boxing of value type.</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = null;
int i = 0;

// ...

string x = s + i;]]></Before>
        <After><![CDATA[string x = s + i.ToString();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UnnecessaryNullCheck">
    <Id>RCS1199</Id>
    <Title>Unnecessary null check.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[bool? x = null;

// ...

if (x.HasValue && x.Value)
{
}]]></Before>
        <After><![CDATA[if (x == true)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool? x = null;
bool y = false;

// ...

if (x != null && x.Value == y)
{
}]]></Before>
        <After><![CDATA[if (x == y)
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="CallThenByInsteadOfOrderBy">
    <Id>RCS1200</Id>
    <Title>Call 'Enumerable.ThenBy' instead of 'Enumerable.OrderBy'.</Title>
    <MessageFormat>Call 'Enumerable.ThenBy{0}' instead of 'Enumerable.OrderBy{0}'.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = items.OrderBy(f => f.Surname).OrderBy(f => f.Name);]]></Before>
        <After><![CDATA[var x = items.OrderBy(f => f.Surname).ThenBy(f => f.Name);]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseMethodChaining">
    <Id>RCS1201</Id>
    <Title>Use method chaining.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[sb = new StringBuilder();

sb.Append("a");
sb.Append("b");
sb.Append("c");]]></Before>
        <After><![CDATA[sb = new StringBuilder();

sb.Append("a")
    .Append("b")
    .Append("c");]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AvoidNullReferenceException">
    <Id>RCS1202</Id>
    <Title>Avoid NullReferenceException.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = items.FirstOrDefault().ToString();]]></Before>
        <After><![CDATA[string s = items.FirstOrDefault()?.ToString();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseAttributeUsageAttribute">
    <Id>RCS1203</Id>
    <Title>Use AttributeUsageAttribute.</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class FooAttribute : Attribute
{
}]]></Before>
        <After><![CDATA[[AttributeUsageAttribute(AttributeTargets.All, AllowMultiple = false)]
public class FooAttribute : Attribute
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseEventArgsEmpty">
    <Id>RCS1204</Id>
    <Title>Use EventArgs.Empty.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = new EventArgs();]]></Before>
        <After><![CDATA[var x = EventArgs.Empty;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="OrderNamedArguments">
    <Id>RCS1205</Id>
    <Title>Order named arguments according to the order of parameters.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[using (var sm = new StreamReader(
    stream: default(Stream),
    encoding: Encoding.UTF8,
    bufferSize: 0,
    leaveOpen: false,
    detectEncodingFromByteOrderMarks: true))
{
}]]></Before>
        <After><![CDATA[using (var sm = new StreamReader(
    stream: default(Stream),
    encoding: Encoding.UTF8,
    detectEncodingFromByteOrderMarks: true,
    bufferSize: 0,
    leaveOpen: false))
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseConditionalAccessInsteadOfConditionalExpression">
    <Id>RCS1206</Id>
    <Title>Use conditional access instead of conditional expression.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <MinLanguageVersion>6.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = new Foo();

// ...

        string s = (x != null) ? x.ToString() : null;]]></Before>
        <After><![CDATA[string s = x?.ToString();]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[int? x = null;

// ...

int i = (x != null) ? x.Value.GetHashCode() : 0;]]></Before>
        <After><![CDATA[int i = x?.GetHashCode() ?? 0;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseAnonymousFunctionOrMethodGroup">
    <Id>RCS1207</Id>
    <Title>Use anonymous function or method group.</Title>
    <MessageFormat>Use {0}.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = items.Select(f => Foo(f));]]></Before>
        <After><![CDATA[var x = items.Select(Foo);]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="use_anonymous_function_or_method_group" IsRequired="true" />
    </ConfigOptions>
    <Options>
      <Option Identifier="ConvertMethodGroupToAnonymousFunction">
        <Title>Convert method group to anonymous function.</Title>
        <Id>i</Id>
        <OptionKey>invert</OptionKey>
        <NewOptionKey>anonymous_function_or_method_group</NewOptionKey>
        <Kind>Invert</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[var x = items.Select(Foo);]]></Before>
            <After><![CDATA[var x = items.Select(f => Foo(f));]]></After>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="ReduceIfNesting">
    <Id>RCS1208</Id>
    <Title>Reduce 'if' nesting.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition1)
{
    Foo1();

    if (condition2)
    {
        Foo2();

        if (condition3)
        {
            Foo3();
        }
    }
}]]></Before>
        <After><![CDATA[if (!condition1)
{
    return;
}

Foo1();

if (!condition2)
{
    return;
}

Foo2();

if (!condition3)
{
    return;
}

Foo3();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="OrderTypeParameterConstraints">
    <Id>RCS1209</Id>
    <Title>Order type parameter constraints.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo<T1, T2, T3>
    where T3 : class
    where T2 : class
    where T1 : class
{
}]]></Before>
        <After><![CDATA[public class Foo<T1, T2, T3>
    where T1 : class
    where T2 : class
    where T3 : class
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="ReturnCompletedTaskInsteadOfNull">
    <Id>RCS1210</Id>
    <Title>Return completed task instead of returning null.</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[Task<object> GetAsync()
{
    return null;
}]]></Before>
        <After><![CDATA[Task<object> GetAsync()
{
    return Task.FromResult<object>(null);
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[Task<object> GetAsync()
{
    return _foo?.GetAsync();
}]]></Before>
        <After><![CDATA[Task<object> GetAsync()
{
    Foo x = _foo;
    if (x != null)
    {
        return _foo.GetAsync();
    }
    else
    {
        return Task.FromResult<object>(null);
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveUnnecessaryElse">
    <Id>RCS1211</Id>
    <Title>Remove unnecessary 'else'.</Title>
    <MessageFormat>Remove unnecessary else clause.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (condition)
{
    return WhenTrue();
}
else
{
    return WhenFalse();
}]]></Before>
        <After><![CDATA[if (condition)
{
    return WhenTrue();
}

return WhenFalse();]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveRedundantAssignment">
    <Id>RCS1212</Id>
    <Title>Remove redundant assignment.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[string x;
x = "";]]></Before>
        <After><![CDATA[string x = "";]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool M()
{
    // ...

    x = false;
    return x;
}]]></Before>
        <After><![CDATA[bool M()
{
    // ...

    return false;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="RemoveUnusedMemberDeclaration">
    <Id>RCS1213</Id>
    <Title>Remove unused member declaration.</Title>
    <MessageFormat>Remove unused {0} declaration.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <ConfigOptions>
      <Option Key="suppress_unity_script_methods" />
    </ConfigOptions>
    <Options>
      <Option Identifier="SuppressUnityScriptMethods">
        <Title>Suppress Unity script methods.</Title>
        <OptionKey>suppress_unity_script_methods</OptionKey>
        <NewOptionKey>supress_unity_script_methods</NewOptionKey>
        <Kind>Disable</Kind>
        <Summary>Suppress diagnostic from [Unity script methods](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html).</Summary>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="UnnecessaryInterpolatedString">
    <Id>RCS1214</Id>
    <Title>Unnecessary interpolated string.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[string s = $"abc";]]></Before>
        <After><![CDATA[string s = "abc";]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[$"{NonNullStringConstant}"]]></Before>
        <After><![CDATA[NonNullStringConstant]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="ExpressionIsAlwaysEqualToTrueOrFalse">
    <Id>RCS1215</Id>
    <Title>Expression is always equal to true/false.</Title>
    <MessageFormat>Expression is always equal to '{0}'.</MessageFormat>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[uint i = 0;

// ...

if (i >= 0)
{
}]]></Before>
      </Sample>
      <Sample>
        <Before><![CDATA[var items = new List<object>();

// ...


if (items.Count < 0)
{
}]]></Before>
      </Sample>
      <Sample>
        <Before><![CDATA[x == double.NaN]]></Before>
        <After><![CDATA[double.IsNaN(x)]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UnnecessaryUnsafeContext">
    <Id>RCS1216</Id>
    <Title>Unnecessary unsafe context.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public unsafe class Foo
{
    public Foo()
    {
        unsafe
        {
            Bar();
        }
    }

    private unsafe void Bar()
    {
    }
}]]></Before>
        <After><![CDATA[public class Foo
{
    public Foo()
    {
        Bar();
    }

    private void Bar()
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="ConvertInterpolatedStringToConcatenation">
    <Id>RCS1217</Id>
    <Title>Convert interpolated string to concatenation.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[$"{a}{b}{c}"]]></Before>
        <After><![CDATA[a + b + c]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="SimplifyCodeBranching">
    <Id>RCS1218</Id>
    <Title>Simplify code branching.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x)
{
}
else
{
  M();
}]]></Before>
        <After><![CDATA[if (!x)
{
  M();
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[while (true)
{
  if (x)
  {
    M();
  }
  else
  {
    break;
  }
}]]></Before>
        <After><![CDATA[while (x)
{
  M();
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[while (true)
{
  if (x)
  {
    break;
  }

  M();
}]]></Before>
        <After><![CDATA[while (!x)
{
  M();
      
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[do
{
  M();

  if (x)
  {
    break;
  }
  
} while (true);]]></Before>
        <After><![CDATA[do
{
  M();

} while (!x);]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (x)
{
  do
  {
    M();
  }
  while (x);]]></Before>
        <After><![CDATA[while (x)
{
  M();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="CallSkipAndAnyInsteadOfCount" IsObsolete="true">
    <Id>RCS1219</Id>
    <Title>Call 'Enumerable.Skip' and 'Enumerable.Any' instead of 'Enumerable.Count'.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (enumerable.Count() > x)
{
}]]></Before>
        <After><![CDATA[if (enumerable.Skip(x).Any())
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UsePatternMatchingInsteadOfIsAndCast">
    <Id>RCS1220</Id>
    <Title>Use pattern matching instead of combination of 'is' operator and cast operator.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <MinLanguageVersion>7.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[if (x is T && Foo((T)x))
{
}]]></Before>
        <After><![CDATA[if (x is T y && Foo(y))
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UsePatternMatchingInsteadOfAsAndNullCheck">
    <Id>RCS1221</Id>
    <Title>Use pattern matching instead of combination of 'as' operator and null check.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <MinLanguageVersion>7.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[var y = x as Foo;

if (y == null)
{
    return;
}]]></Before>
        <After><![CDATA[if (!(x is Foo y))
{
    return;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="MergePreprocessorDirectives">
    <Id>RCS1222</Id>
    <Title>Merge preprocessor directives.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[#pragma warning disable CS0000
#pragma warning disable CS0001
]]></Before>
        <After><![CDATA[#pragma warning disable CS0000, CS0001]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="MarkTypeWithDebuggerDisplayAttribute">
    <Id>RCS1223</Id>
    <Title>Mark publicly visible type with DebuggerDisplay attribute.</Title>
    <MessageFormat>Mark '{0}' with DebuggerDisplay attribute.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
}]]></Before>
        <After><![CDATA[[DebuggerDisplay("{DebuggerDisplay,nq}")]
public class Foo
{
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private string DebuggerDisplay
    {
        get { return ToString(); }
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="MakeMethodExtensionMethod">
    <Id>RCS1224</Id>
    <Title>Make method an extension method.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Summary>Public/internal method in public/internal static class whose name ends with "Extensions" should be an extension method.</Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[public static class FooExtensions
{
    public static string Bar(Foo foo)
    {
    }
}]]></Before>
        <After><![CDATA[public static class FooExtensions
{
    public static string Bar(this Foo foo)
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="MakeClassSealed">
    <Id>RCS1225</Id>
    <Title>Make class sealed.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Summary>A class that has only private constructors should be marked as sealed.</Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[public class Foo
{
    private Foo()
    {
    }
}]]></Before>
        <After><![CDATA[public sealed class Foo
{
    private Foo()
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AddParagraphToDocumentationComment">
    <Id>RCS1226</Id>
    <Title>Add paragraph to documentation comment.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// summary1
/// 
/// summary2
/// summary3
/// </summary>
class Foo
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// <para>summary1</para>
/// <para>
/// summary2
/// summary3
/// </para>
/// </summary>
class Foo
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="ValidateArgumentsCorrectly">
    <Id>RCS1227</Id>
    <Title>Validate arguments correctly.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Summary>
      An iterator method (a method that contains `yield`) will not validate arguments until the caller begins to enumerate the result items.

      To ensure that arguments are validated immediately (when the method is called), move
      the iterator to a separate method (local function).
    </Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[IEnumerable<object> Foo(IEnumerable<object> items)
{
    if (items == null)
        throw new ArgumentNullException(nameof(items));

    foreach (object item in items)
        yield return item;
}]]></Before>
        <After><![CDATA[IEnumerable<object> Foo(IEnumerable<object> items)
{
    if (items == null)
        throw new ArgumentNullException(nameof(items));

    return FooIterator();

    IEnumerable<object> FooIterator()
    {
        foreach (object item in items)
            yield return item;    
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UnusedElementInDocumentationComment">
    <Id>RCS1228</Id>
    <Title>Unused element in documentation comment.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// 
/// </summary>
/// <returns></returns>
public string Foo()
{
    return null;
}
]]></Before>
        <After><![CDATA[/// <summary>
/// 
/// </summary>
public string Foo()
{
    return null;
}
]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseAsyncAwait">
    <Id>RCS1229</Id>
    <Title>Use async/await when necessary.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[Task<object> FooAsync()
{
    using (var service = CreateService())
    {
        return service.GetAsync();
    }
}
]]></Before>
        <After><![CDATA[async Task<object> FooAsync()
{
    using (var service = CreateService())
    {
        return await service.GetAsync();
    }
}]]></After>
      </Sample>
    </Samples>
    <Links>
      <Link>
        <Url>http://thebillwagner.com/Blog/Item/2017-05-03-ThecuriouscaseofasyncawaitandIDisposable</Url>
        <Text>The curious case of async, await, and IDisposable</Text>
      </Link>
    </Links>
  </Analyzer>
  <Analyzer Identifier="UnnecessaryExplicitUseOfEnumerator">
    <Id>RCS1230</Id>
    <Title>Unnecessary explicit use of enumerator.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[using (var en = items.GetEnumerator())
{
    while (en.MoveNext())
    {
        yield return en.Current;
    }
}]]></Before>
        <After><![CDATA[foreach (var item in items)
{
    yield return item;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="MakeParameterRefReadOnly">
    <Id>RCS1231</Id>
    <Title>Make parameter ref read-only.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <MinLanguageVersion>7.2</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[readonly struct C
{
    void M(C c)
    {
    }
}]]></Before>
        <After><![CDATA[readonly struct C
{
    void M(in C c)
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="OrderElementsInDocumentationComment">
    <Id>RCS1232</Id>
    <Title>Order elements in documentation comment.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[class C
{
    /// <summary></summary>
    /// <param name="p3"></param>
    /// <param name="p2"></param>
    /// <param name="p1"></param>
    void M(object p1, object p2, object p3)
    {
    }
}]]></Before>
        <After><![CDATA[class C
{
    /// <summary></summary>
    /// <param name="p1"></param>
    /// <param name="p2"></param>
    /// <param name="p3"></param>
    void M(object p1, object p2, object p3)
    {
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseShortCircuitingOperator">
    <Id>RCS1233</Id>
    <Title>Use short-circuiting operator.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[boolExpr1 & boolExpr2]]></Before>
        <After><![CDATA[boolExpr1 && boolExpr2]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[boolExpr1 | boolExpr2]]></Before>
        <After><![CDATA[boolExpr1 || boolExpr2]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="DuplicateEnumValue">
    <Id>RCS1234</Id>
    <Title>Duplicate enum value.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[enum E
{
    A = 1,
    B = 2,
    C = 2,
}]]></Before>
        <After><![CDATA[enum E
{
    A = 1,
    B = 2,
    C = B,
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="OptimizeMethodCall">
    <Id>RCS1235</Id>
    <Title>Optimize method call.</Title>
    <MessageFormat>Optimize '{0}' call.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[string.Compare(x, y, StringComparison.Ordinal)]]></Before>
        <After><![CDATA[string.CompareOrdinal(x, y)]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[string.Compare(x, y, StringComparison.CurrentCulture) == 0]]></Before>
        <After><![CDATA[string.Equals(x, y, StringComparison.CurrentCulture)]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[string.Join("", x, z, y)]]></Before>
        <After><![CDATA[string.Concat(x, y, z)]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[Debug.Assert(false, "message");]]></Before>
        <After><![CDATA[Debug.Fail("message");]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (dic.ContainsKey(key))
{
  dic[key] = value;
}
else
{
  dic.Add(key, value);
}]]></Before>
        <After><![CDATA[dic[key] = value;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseExceptionFilter">
    <Id>RCS1236</Id>
    <Title>Use exception filter.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <MinLanguageVersion>6.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[try
{
}
catch (Exception ex)
{
    if (!(ex is InvalidOperationException))
    {
        throw;
    }

    return;
}]]></Before>
        <After><![CDATA[try
{
}
catch (Exception ex) when (ex is InvalidOperationException)
{
    return;
}]]></After>
      </Sample>
    </Samples>
    <Remarks>The accepted [answer](https://stackoverflow.com/a/28879616) from Stack Overflow states:
&gt;"If there is an exception thrown within the filter, then that exception will be silently swallowed and the filter simply fails."

It is impossible to definitely detect if an exception can be thrown within an expression.

So the expression is considered as the one that can throw an exception if it contains method call that meets one of the following requirements:

* Its name starts with `ThrowIf`.
* Its XML comment contains `&lt;exception&gt;` element.</Remarks>
    <Links>
      <Link>
        <Url>https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6#exception-filters</Url>
        <Text>What's New in C# 6.0 - Exception Filters</Text>
      </Link>
      <Link>
        <Url>https://thomaslevesque.com/2015/06/21/exception-filters-in-c-6/</Url>
        <Text>Exception filters in C# 6: their biggest advantage is not what you think</Text>
      </Link>
    </Links>
  </Analyzer>
  <Analyzer Identifier="UseBitShiftOperator">
    <Id>RCS1237</Id>
    <Title>([deprecated] use RCS1254 instead) Use bit shift operator.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Tags>HideFromConfiguration</Tags>
    <Samples>
      <Sample>
        <Before><![CDATA[[Flags]
enum Foo
{
    None = 0,
    Alpha = 1,
    Beta = 2,
    Gamma = 4,
}]]></Before>
        <After><![CDATA[[Flags]
enum Foo
{
    None = 0,
    Alpha = 1,
    Beta = 1 << 1,
    Gamma = 1 << 2,
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="AvoidNestedConditionalOperators">
    <Id>RCS1238</Id>
    <Title>Avoid nested ?: operators.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[var x = (a) ? "a" : (b) ? "b" : "c";]]></Before>
        <After><![CDATA[var x;
if (a)
{
    x = "a";
}
else if (b)
{
    x = "b";
}
else
{
    x = "c";
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseForStatementInsteadOfWhileStatement">
    <Id>RCS1239</Id>
    <Title>Use 'for' statement instead of 'while' statement.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[int i = 0;
while (x)
{
    M();
    i++;
}]]></Before>
        <After><![CDATA[for (int i = 0; x; i++)
{
    M();
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UnnecessaryOperator">
    <Id>RCS1240</Id>
    <Title>Operator is unnecessary.</Title>
    <MessageFormat>The '{0}' operator is unnecessary.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[array.Length <= 0]]></Before>
        <After><![CDATA[array.Length == 0]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="ImplementNonGenericCounterpart">
    <Id>RCS1241</Id>
    <Title>Implement non-generic counterpart.</Title>
    <MessageFormat>Implement {0} when implementing {1}&lt;T&gt;.</MessageFormat>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Summary>Publicly visible type that implements `IComparable&lt;T&gt;`, `IComparer&lt;T&gt;` or `IEqualityComparer&lt;T&gt;` should implement their non-generic counterpart.</Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[using System;
using System.Collections.Generic;

public class C
{
}

public abstract class Comparable : IComparable<C>
{
    public abstract int CompareTo(C other);
}]]></Before>
        <After><![CDATA[using System;
using System.Collections.Generic;

public class C
{
}

public abstract class Comparable : IComparable<C>, IComparable
{
    public abstract int CompareTo(C other);

    public int CompareTo(object obj)
    {
        if (obj == null)
        {
            return 1;
        }

        if (obj is C x)
        {
            return CompareTo(x);
        }

        throw new ArgumentException("""", nameof(obj));
    }
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;

public class C
{
}

public abstract class Comparer : IComparer<C>
{
    public abstract int Compare(C x, C y);
}]]></Before>
        <After><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;

public class C
{
}

public abstract class Comparer : IComparer<C>, IComparer
{
    public abstract int Compare(C x, C y);

    public int Compare(object x, object y)
    {
        if (x == y)
        {
            return 0;
        }

        if (x == null)
        {
            return -1;
        }

        if (y == null)
        {
            return 1;
        }

        if (x is global::C a
            && y is global::C b)
        {
            return Compare(a, b);
        }

        if (x is IComparable ic)
        {
            return ic.CompareTo(y);
        }

        throw new ArgumentException("""", nameof(x));
    }
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;

public class C
{
}

public abstract class EqualityComparer : IEqualityComparer<C>
{
    public abstract bool Equals(C x, C y);

    public abstract int GetHashCode(C obj);
}]]></Before>
        <After><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;

public class C
{
}

public abstract class EqualityComparer : IEqualityComparer<C>, IEqualityComparer
{
    public abstract bool Equals(C x, C y);

    public abstract int GetHashCode(C obj);

    new public bool Equals(object x, object y)
    {
        if (x == y)
        {
            return true;
        }

        if (x == null || y == null)
        {
            return false;
        }

        if (x is global::C a
            && y is global::C b)
        {
            return Equals(a, b);
        }

        return x.Equals(y);
    }

    public int GetHashCode(object obj)
    {
        if (obj == null)
        {
            throw new ArgumentNullException(nameof(obj));
        }

        if (obj is C x)
        {
            return GetHashCode(x);
        }

        return obj.GetHashCode();
    }
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="DoNotPassNonReadOnlyStructByReadOnlyReference">
    <Id>RCS1242</Id>
    <Title>Do not pass non-read-only struct by read-only reference.</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <MinLanguageVersion>7.2</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[struct C
{
    void M(in C c)
    {
    }
}]]></Before>
        <After><![CDATA[struct C
{
    void M(C c)
    {
    }
}]]></After>
      </Sample>
    </Samples>
    <Links>
      <Link>
        <Url>https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/in-parameter-modifier</Url>
        <Text>in parameter modifier (C# Reference)</Text>
      </Link>
      <Link>
        <Url>https://devblogs.microsoft.com/premier-developer/the-in-modifier-and-the-readonly-structs-in-c/</Url>
        <Text>The 'in'-modifier and the readonly structs in C#</Text>
      </Link>
    </Links>
  </Analyzer>
  <Analyzer Identifier="DuplicateWordInComment">
    <Id>RCS1243</Id>
    <Title>Duplicate word in a comment.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// This is the the comment.
/// </summary>
public class C
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// This is the comment.
/// </summary>
public class C
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="SimplifyDefaultExpression">
    <Id>RCS1244</Id>
    <Title>Simplify 'default' expression.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <MinLanguageVersion>7.1</MinLanguageVersion>
    <Summary>This analyzer is similar to [IDE0034](https://docs.microsoft.com/visualstudio/ide/common-quick-actions#remove-type-from-default-value-expression) but there are some differences. For example this analyzer does not simplify 'default' expression passed as an argument expression.</Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[Foo M(Foo foo = default(Foo))
{
    return default(Foo);
}]]></Before>
        <After><![CDATA[Foo M(Foo foo = default)
{
    return default;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="SimplifyConditionalExpression2" IsObsolete="true">
    <Id>RCS1245</Id>
    <Title>Simplify conditional expression.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[bool x = y ? false : z;]]></Before>
        <After><![CDATA[bool x = !y && z;]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[bool x = y ? z : true;]]></Before>
        <After><![CDATA[bool x = !y || z;]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseElementAccess">
    <Id>RCS1246</Id>
    <Title>Use element access.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[list.First()]]></Before>
        <After><![CDATA[list[0]]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[list.ElementAt(1)]]></Before>
        <After><![CDATA[list[1]]]></After>
      </Sample>
    </Samples>
    <Options>
      <Option Identifier="DoNotUseElementAccessWhenExpressionIsInvocation" IsObsolete="true">
        <Title>Do not use element access when expression is invocation.</Title>
        <Id>a</Id>
        <OptionKey>suppress_when_expression_is_invocation</OptionKey>
        <Kind>Disable</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[M().First()]]></Before>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="FixDocumentationCommentTag">
    <Id>RCS1247</Id>
    <Title>Fix documentation comment tag.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[/// <summary>
/// <code>null</code>
/// </summary>
void M()
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// <c>null<c>
/// </summary>
void M()
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[/// <summary>
/// <c>
/// if (x == null)
///     x = new object();
/// </c>
/// </summary>
void M()
{
}]]></Before>
        <After><![CDATA[/// <summary>
/// <code>
/// if (x == null)
///     x = new object();
/// </code>
/// </summary>
void M()
{
}]]></After>
      </Sample>
    </Samples>
    <Links>
      <Link>
        <Url>https://docs.microsoft.com/dotnet/csharp/programming-guide/xmldoc/recommended-tags-for-documentation-comments</Url>
        <Text>Recommended tags for documentation comments (C# programming guide)</Text>
      </Link>
    </Links>
  </Analyzer>
  <Analyzer Identifier="NormalizeNullCheck">
    <Id>RCS1248</Id>
    <Title>Normalize null check.</Title>
    <MessageFormat>Use {0} to check for null.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <MinLanguageVersion>7.0 (9.0 for 'is not null' syntax)</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[x == null]]></Before>
        <After><![CDATA[x is null]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="null_check_style" IsRequired="true" />
    </ConfigOptions>
    <Options>
      <Option Identifier="UseComparisonInsteadPatternMatchingToCheckForNull">
        <Id>i</Id>
        <Title>Use comparison instead of pattern matching to check for null.</Title>
        <OptionKey>invert</OptionKey>
        <NewOptionKey>null_check_style</NewOptionKey>
        <Kind>Invert</Kind>
        <Samples>
          <Sample>
            <Before><![CDATA[x is null]]></Before>
            <After><![CDATA[x == null]]></After>
          </Sample>
          <Sample>
            <Before><![CDATA[x is not null]]></Before>
            <After><![CDATA[x != null]]></After>
          </Sample>
        </Samples>
      </Option>
    </Options>
  </Analyzer>
  <Analyzer Identifier="UnnecessaryNullForgivingOperator">
    <Id>RCS1249</Id>
    <Title>Unnecessary null-forgiving operator.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <MinLanguageVersion>8.0</MinLanguageVersion>
  </Analyzer>
  <Analyzer Identifier="UseImplicitOrExplicitObjectCreation">
    <Id>RCS1250</Id>
    <Title>Use implicit/explicit object creation.</Title>
    <MessageFormat>Use {0} object creation.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <MinLanguageVersion>9.0</MinLanguageVersion>
    <Samples>
      <Sample>
        <Before><![CDATA[private string _value = new string(' ', 1)]]></Before>
        <After><![CDATA[private string _value = new(' ', 1)]]></After>
      </Sample>
    </Samples>
    <ConfigOptions>
      <Option Key="object_creation_type_style" IsRequired="true" />
      <Option Key="use_var_instead_of_implicit_object_creation" />
    </ConfigOptions>
    <Links>
      <Link>
        <Url>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/target-typed-new</Url>
        <Text>Target-typed new expressions</Text>
      </Link>
    </Links>
  </Analyzer>
  <Analyzer Identifier="RemoveUnnecessaryBraces">
    <Id>RCS1251</Id>
    <Title>Remove unnecessary braces from record declaration.</Title>
    <MessageFormat>Remove unnecessary braces.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[public record Foo(string Value1, string Value2)
{
}]]></Before>
        <After><![CDATA[public record Foo(string Value1, string Value2);]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="NormalizeUsageOfInfiniteLoop">
    <Id>RCS1252</Id>
    <Title>Normalize usage of infinite loop.</Title>
    <MessageFormat>Use '{0}' statement as an infinite loop.</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <ConfigOptions>
      <Option Key="infinite_loop_style" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer Identifier="FormatDocumentationCommentSummary">
    <Id>RCS1253</Id>
    <Title>Format documentation comment summary.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Summary>This analyzer replaces RCS1100 and RCS1101.</Summary>
    <ConfigOptions>
      <Option Key="doc_comment_summary_style" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer Identifier="NormalizeFormatOfEnumFlagValue">
    <Id>RCS1254</Id>
    <Title>Normalize format of enum flag value.</Title>
    <MessageFormat>{0}</MessageFormat>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <ConfigOptions>
      <Option Key="enum_flag_value_style" IsRequired="true" />
    </ConfigOptions>
  </Analyzer>
  <Analyzer Identifier="SimplifyArgumentNullCheck">
    <Id>RCS1255</Id>
    <Title>Simplify argument null check.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>false</IsEnabledByDefault>
    <Summary>Use `ArgumentNullException.ThrowIfNull` instead of `if` null check.</Summary>
    <Samples>
      <Sample>
        <Before><![CDATA[if (arg is null)
{
    throw new ArgumentNullException(nameof(arg));
}]]></Before>
        <After><![CDATA[ArgumentNullException.ThrowIfNull(arg);]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="InvalidArgumentNullCheck">
    <Id>RCS1256</Id>
    <Title>Invalid argument null check.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Summary>This analyzer reports null checks of arguments that are:
- annotated as nullable reference type.
- optional and its default value is `null`.
    </Summary>
  </Analyzer>
  <Analyzer Identifier="UsePatternMatching">
    <Id>RCS9001</Id>
    <Title>Use pattern matching.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[if (syntaxNode.IsKind(SyntaxKind.IdentifierName))
{
    var identifierName = (IdentifierNameSyntax)syntaxNode;
}]]></Before>
        <After><![CDATA[if (syntaxNode is IdentifierNameSyntax identifierName)
{
}]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[if (!syntaxNode.IsKind(SyntaxKind.IdentifierName))
{
    return;
}

var identifierName = (IdentifierNameSyntax)syntaxNode;
]]></Before>
        <After><![CDATA[if (!(syntaxNode is IdentifierNameSyntax identifierName))
{
  return;
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UsePropertySyntaxNodeSpanStart">
    <Id>RCS9002</Id>
    <Title>Use property SyntaxNode.SpanStart.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[node.Span.Start]]></Before>
        <After><![CDATA[node.SpanStart]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UnnecessaryConditionalAccess">
    <Id>RCS9003</Id>
    <Title>Unnecessary conditional access.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <SupportsFadeOutAnalyzer>true</SupportsFadeOutAnalyzer>
    <Samples>
      <Sample>
        <Before><![CDATA[node?.IsKind(kind) == true]]></Before>
        <After><![CDATA[node.IsKind(kind)]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="CallAnyInsteadOfAccessingCount">
    <Id>RCS9004</Id>
    <Title>Call 'Any' instead of accessing 'Count'.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[syntaxList.Count > 0]]></Before>
        <After><![CDATA[syntaxList.Any()]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[syntaxList.Count == 0]]></Before>
        <After><![CDATA[!syntaxList.Any()]]></After>
      </Sample>
    </Samples>
    <Remarks>This analyzer is applicable for following types:
* `Microsoft.CodeAnalysis.ChildSyntaxList`
* `Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;`
* `Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt;`
* `Microsoft.CodeAnalysis.SyntaxNodeOrTokenList`
* `Microsoft.CodeAnalysis.SyntaxTokenList`
* `Microsoft.CodeAnalysis.SyntaxTriviaList`</Remarks>
  </Analyzer>
  <Analyzer Identifier="UnnecessaryNullCheck">
    <Id>RCS9005</Id>
    <Title>Unnecessary null check.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <SupportsFadeOut>true</SupportsFadeOut>
    <Samples>
      <Sample>
        <Before><![CDATA[syntaxNode != null && syntaxNode.IsKind(kind)]]></Before>
        <After><![CDATA[syntaxNode.IsKind(kind)]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="UseElementAccess">
    <Id>RCS9006</Id>
    <Title>Use element access.</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[syntaxList.First()]]></Before>
        <After><![CDATA[syntaxList[0]]]></After>
      </Sample>
      <Sample>
        <Before><![CDATA[triviaList.ElementAt(1)]]></Before>
        <After><![CDATA[triviaList[1]]]></After>
      </Sample>
    </Samples>
    <Remarks>This analyzer is applicable for following types:
* `Microsoft.CodeAnalysis.ChildSyntaxList`
* `Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;`
* `Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt;`
* `Microsoft.CodeAnalysis.SyntaxNodeOrTokenList`
* `Microsoft.CodeAnalysis.SyntaxTokenList`
* `Microsoft.CodeAnalysis.SyntaxTriviaList`</Remarks>
  </Analyzer>
  <Analyzer Identifier="UseReturnValue">
    <Id>RCS9007</Id>
    <Title>Use return value.</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[ifStatement.WithCondition(newCondition);]]></Before>
        <After><![CDATA[var x = ifStatement.WithCondition(newCondition);]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="CallLastInsteadOfUsingElementAccess">
    <Id>RCS9008</Id>
    <Title>Call 'Last' instead of using [].</Title>
    <DefaultSeverity>Info</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[syntaxList[syntaxList.Count - 1]]]></Before>
        <After><![CDATA[!syntaxList.Last()]]></After>
      </Sample>
    </Samples>
    <Remarks>This analyzer is applicable for following types:
* `Microsoft.CodeAnalysis.ChildSyntaxList`
* `Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;`
* `Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt;`
* `Microsoft.CodeAnalysis.SyntaxNodeOrTokenList`
* `Microsoft.CodeAnalysis.SyntaxTokenList`
* `Microsoft.CodeAnalysis.SyntaxTriviaList`</Remarks>
  </Analyzer>
  <Analyzer Identifier="UnknownLanguageName">
    <Id>RCS9009</Id>
    <Title>Unknown language name.</Title>
    <DefaultSeverity>Warning</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[[DiagnosticAnalyzer("C")]
class FooDiagnosticAnalyzer : DiagnosticAnalyzer
{
}]]></Before>
        <After><![CDATA[[DiagnosticAnalyzer("C#")]
class FooDiagnosticAnalyzer : DiagnosticAnalyzer
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="SpecifyExportCodeRefactoringProviderAttributeName">
    <Id>RCS9010</Id>
    <Title>Specify ExportCodeRefactoringProviderAttribute.Name.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[[ExportCodeRefactoringProvider(LanguageNames.CSharp)]
class FooCodeRefactoringProvider : CodeRefactoringProvider
{
}]]></Before>
        <After><![CDATA[[ExportCodeRefactoringProvider(LanguageNames.CSharp, Name = nameof(FooCodeRefactoringProvider))]
class FooCodeRefactoringProvider : CodeRefactoringProvider
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
  <Analyzer Identifier="SpecifyExportCodeFixProviderAttributeName">
    <Id>RCS9011</Id>
    <Title>Specify ExportCodeFixProviderAttribute.Name.</Title>
    <DefaultSeverity>Hidden</DefaultSeverity>
    <IsEnabledByDefault>true</IsEnabledByDefault>
    <Samples>
      <Sample>
        <Before><![CDATA[[ExportCodeFixProvider(LanguageNames.CSharp)]
class FooCodeFixProvider : CodeFixProvider
{
}]]></Before>
        <After><![CDATA[[ExportCodeFixProvider(LanguageNames.CSharp, Name = nameof(FooCodeFixProvider))]
class FooCodeFixProvider : CodeFixProvider
{
}]]></After>
      </Sample>
    </Samples>
  </Analyzer>
</Analyzers>